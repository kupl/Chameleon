*help.txt*	For Vim version 5.7.  Last change: 2000 Jan 01

			VIM - main help file
									 k
      Move around:  Use the cursor keys, or "h" to go left,	       h   l
		    "j" to go down, "k" to go up, "l" to go right.	 j
Close this window:  Use ":q<Enter>".
   Get out of Vim:  Use ":qa!<Enter>" (careful, all changes are lost!).
Jump to a subject:  Position the cursor on a tag between |bars| and hit CTRL-].
   With the mouse:  ":set mouse=a" to enable the mouse (in xterm or GUI).
		    Double-click the left mouse button on a tag between |bars|.
	jump back:  Type CTRL-T or CTRL-O.
Get specific help:  It is possible to go directly to whatever you want help
		    on, by giving an argument to the ":help" command |:help|.
		    It is possible to further specify the context:
			  WHAT			PREPEND    EXAMPLE	~
		      Normal mode commands     (nothing)   :help x
		      Visual mode commands	  v_	   :help v_u
		      Insert mode commands	  i_	   :help i_<Esc>
		      Command-line commands	  :	   :help :quit
		      Command-line editing	  c_	   :help c_<Del>
		      Vim command arguments	  -	   :help -r
		      options			  '	   :help 'textwidth'
  Search for help:  Type ":help word", then hit CTRL-D to see matching
		    help entries for "word".

VIM stands for Vi IMproved.  Most of VIM was made by Bram Moolenaar, but only
through the help of a lot of people.  See |credits|.
------------------------------------------------------------------------------
 tag	  subject			 tag	  subject	~
							 *quickref* *Contents*
|X_ct|  detailed help files		|X_re|	Repeating commands
|X_lr|	motion: Left-right		|X_km|	Key mapping
|X_ud|	motion: Up-down			|X_ab|	Abbreviations
|X_tm|	motion: Text object		|X_op|	Options
|X_pa|	motion: Pattern searches	|X_ur|	Undo/Redo commands
|X_ma|	motion: Marks			|X_et|	External commands
|X_vm|	motion: Various			|X_qf|	Quickfix commands
|X_ta|	motion: Using tags		|X_vc|	Various commands
|X_sc|	Scrolling			|X_ce|	Ex: Command-line editing
|X_in|	insert: Inserting text		|X_ra|	Ex: Ranges
|X_ai|	insert: Keys			|X_ex|	Ex: Special characters
|X_ss|	insert: Special keys		|X_ed|	Editing a file
|X_di|	insert: Digraphs		|X_fl|	Using the argument list
|X_si|	insert: Special inserts		|X_wq|	Writing and quitting
|X_de|	change: Deleting text		|X_st|	Starting VIM
|X_cm|	change: Copying and moving	|X_ac|	Automatic commands
|X_ch|	change: Changing text		|X_wi|	Multi-window functions
|X_co|	change: Complex			|X_bu|	Buffer list functions
|X_vi|	Visual mode			|X_sy|	Syntax highlighting
|X_to|	Text objects			|X_gu|	GUI commands

|tutor|		30 minutes training course for beginners
|copying|	About copyrights and Uganda
|www|		Vim on the World Wide Web
|bugs|		Where to send bug reports
------------------------------------------------------------------------------
Detailed documentation files:			*doc-file-list* *X_ct*

General subjects ~
|intro.txt|	general introduction to Vim; notation used in help files
|help.txt|	overview and quick reference (this file)
|index.txt|	alphabetical index of all commands
|help-tags|	all the tags you can jump to (index of tags)
|howto.txt|	how to do the most common editing tasks
|tips.txt|	various tips on using Vim
|message.txt|	(error) messages and explanations
|quotes.txt|	remarks from users of Vim
|todo.txt|	known problems and desired extensions
|develop.txt|	development of Vim
|uganda.txt|	Vim distribution conditions and what to do with your money

Basic editing ~
|starting.txt|	starting Vim, Vim command arguments, initialisation
|editing.txt|	editing and writing files
|motion.txt|	commands for moving around
|scroll.txt|	scrolling the text in the window
|insert.txt|	Insert and Replace mode
|change.txt|	deleting and replacing text
|undo.txt|	Undo and Redo
|repeat.txt|	repeating commands
|visual.txt|	using the Visual mode (selecting a text area)
|various.txt|	various remaining commands
|recover.txt|	recovering from a crash

Advanced editing ~
|cmdline.txt|	Command-line editing
|options.txt|	description of all options
|pattern.txt|	regexp patterns and search commands
|map.txt|	key mapping and abbreviations
|tagsearch.txt|	tags and special searches
|quickfix.txt|	commands for a quick edit-compile-fix cycle
|windows.txt|	commands for using multiple windows and buffers
|syntax.txt|	syntax highlighting
|autocmd.txt|	automatically executing commands on an event
|eval.txt|	expression evaluation, conditional commands

Special issues ~
|term.txt|	using different terminals and mice
|digraph.txt|	list of available digraphs
|multibyte.txt|	multi-byte text support
|farsi.txt|	Farsi (Persian) editing
|hangulin.txt|	Hangul (Korean) input mode
|rightleft.txt|	right-to-left editing

GUI ~
|gui.txt|	Graphical User Interface (GUI)
|gui_w32.txt|	Win32 GUI
|gui_x11.txt|	X11 GUI

Interfaces ~
|if_cscope.txt|	using cscope with Vim
|if_perl.txt|	Perl interface
|if_python.txt|	Python interface
|if_sniff.txt|	SNiFF+ interface
|if_tcl.txt|	Tcl interface
|if_ole.txt|	OLE automation interface for Win32

Versions ~
|vi_diff.txt|	main differences between Vim and Vi
|version4.txt|	differences between Vim version 3.0 and 4.x
|version5.txt|	differences between Vim version 4.6 and 5.x
						*sys-file-list*
Remarks about specific systems ~
|os_amiga.txt|	Amiga
|os_beos.txt|	BeOS and BeBox
|os_dos.txt|	MS-DOS and MS-Windows NT/95 common items
|os_mac.txt|	Macintosh
|os_mint.txt|	Atari MiNT
|os_msdos.txt|	MS-DOS (plain DOS and DOS box under Windows)
|os_os2.txt|	OS/2
|os_riscos.txt|	RISC-OS
|os_unix.txt|	Unix
|os_vms.txt|	VMS
|os_win32.txt|	MS-Windows 95/98/NT
------------------------------------------------------------------------------
N is used to indicate an optional count that can be given before the command.
------------------------------------------------------------------------------
*X_lr*		Left-right motions

|h|	N  h		left (also: CTRL-H, <BS>, or <Left> key)
|l|	N  l		right (also: <Space> or <Right> key)
|0|	   0		to first character in the line (also: <Home> key)
|^|	   ^		to first non-blank character in the line
|$|	N  $		to the last character in the line (N-1 lines lower)
			   (also: <End> key)
|g0|	N  g0		to first character in screen line (differs from "0"
			   when lines wrap)
|g^|	N  g^		to first non-blank character in screen line (differs
			   from "^" when lines wrap)
|g$|	N  g$		to last character in screen line (differs from "$"
			   when lines wrap)
|gm|	N  gm		to middle of the screen line
|bar|	N  |		to column N (default: 1)
|f|	N  f{char}	to the Nth occurrence of {char} to the right
|F|	N  F{char}	to the Nth occurrence of {char} to the left
|t|	N  t{char}	till before the Nth occurrence of {char} to the right
|T|	N  T{char}	till before the Nth occurrence of {char} to the left
|;|	N  ;		repeat the last "f", "F", "t", or "T" N times
|,|	N  ,		repeat the last "f", "F", "t", or "T" N times in
			   opposite direction
------------------------------------------------------------------------------
*X_ud*		Up-down motions

|k|	N  k		up N lines (also: CTRL-P and <Up>)
|j|	N  j		down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
|-|	N  -		up N lines, on the first non-blank character
|+|	N  +		down N lines, on the first non-blank character (also:
			   CTRL-M and <CR>)
|_|	N  _		down N-1 lines, on the first non-blank character
|G|	N  G		goto line N (default: last line), on the first
			   non-blank character
|gg|	N  gg		goto line N (default: first line), on the first
			   non-blank character
|N%|	N  %		goto line N percentage down in the file.  N must be
			   given, otherwise it is the |%| command.
|gk|	N  gk		up N screen lines (differs from "k" when line wraps)
|gj|	N  gj		down N screen lines (differs from "j" when line wraps)
------------------------------------------------------------------------------
*X_tm*		Text object motions

|w|	N  w		N words forward
|W|	N  W		N blank-separated WORDS forward
|e|	N  e		forward to the end of the Nth word
|E|	N  E		forward to the end of the Nth blank-separated WORD
|b|	N  b		N words backward
|B|	N  B		N blank-separated WORDS backward
|ge|	N  ge		backward to the end of the Nth word
|gE|	N  gE		backward to the end of the Nth blank-separated WORD

|)|	N  )		N sentences forward
|(|	N  (		N sentences backward
|}|	N  }		N paragraphs forward
|{|	N  {		N paragraphs backward
|]]|	N  ]]		N sections forward, at start of section
|[[|	N  [[		N sections backward, at start of section
|][|	N  ][		N sections forward, at end of section
|[]|	N  []		N sections backward, at end of section
|[(|	N  [(		N times back to unclosed '('
|[{|	N  [{		N times back to unclosed '{'
|[m|	N  [m		N times back to start method (for Java)
|])|	N  ])		N times forward to unclosed ')'
|]}|	N  ]}		N times forward to unclosed '}'
|]m|	N  ]m		N times forward to end method (for Java)
|[#|	N  [#		N times back to unclosed "#if" or "#else"
|]#|	N  ]#		N times forward to unclosed "#else" or "#endif"
|[star|	N  [*		N times back to start of comment "/*"
|]star|	N  ]*		N times forward to end of comment "*/"
------------------------------------------------------------------------------
*X_pa*		Pattern searches

|/|	N  /{pattern}[/[offset]]<CR>
			search forward for the Nth occurrence of {pattern}
|?|	N  ?{pattern}[?[offset]]<CR>
			search backward for the Nth occurrence of {pattern}
|/<CR>|	N  /<CR>	repeat last search, in the forward direction
|?<CR>|	N  ?<CR>	repeat last search, in the backward direction
|n|	N  n		repeat last search
|N|	N  N		repeat last search, in opposite direction
|star|	N  *		search forward for the identifier under the cursor
|#|	N  #		search backward for the identifier under the cursor
|gstar|	N  g*		like "*", but also find partial matches
|g#|	N  g#		like "#", but also find partial matches
|gd|	   gd		goto local declaration of identifier under the cursor
|gD|	   gD		goto global declaration of identifier under the cursor

|pattern|		Special characters in search patterns

			meaning		      magic   nomagic	~
		matches any single character	.	\.
		       matches start of line	^	^
			       matches <EOL>	$	$
		       matches start of word	\<	\<
			 matches end of word	\>	\>
	matches a single char from the range	[a-z]	\[a-z]
      matches a single char not in the range	[^a-z]	\[^a-z]
		  matches an identifier char	\i	\i
		   idem but excluding digits	\I	\I
		 matches a keyword character	\k	\k
		   idem but excluding digits	\K	\K
	       matches a file name character	\f	\f
		   idem but excluding digits	\F	\F
	       matches a printable character	\p	\p
		   idem but excluding digits	\P	\P
	     matches a white space character	\s	\s
	 matches a non-white space character	\S	\S

			       matches <Esc>	\e	\e
			       matches <Tab>	\t	\t
				matches <CR>	\r	\r
				matches <BS>	\b	\b

     matches 0 or more of the preceding atom	*	\*
     matches 1 or more of the preceding atom	\+	\+
	matches 0 or 1 of the preceding atom	\=	\=
		      separates two branches	\|	\|
		group a pattern into an atom	\(\)	\(\)

|search-offset|		Offsets allowed after search command

    [num]	[num] lines downwards, in column 1
    +[num]	[num] lines downwards, in column 1
    -[num]	[num] lines upwards, in column 1
    e[+num]	[num] characters to the right of the end of the match
    e[-num]	[num] characters to the left of the end of the match
    s[+num]	[num] characters to the right of the start of the match
    s[-num]	[num] characters to the left of the start of the match
    b[+num]	[num] characters to the right of the start (begin) of the match
    b[-num]	[num] characters to the left of the start (begin) of the match
    ;{search-command}	execute {search-command} next
------------------------------------------------------------------------------
*X_ma*		Marks and motions

|m|	   m{a-zA-Z}	mark current position with mark {a-zA-Z}
|`a|	   `{a-z}	go to mark {a-z} within current file
|`A|	   `{A-Z}	go to mark {A-Z} in any file
|`0|	   `{0-9}	go to the position where Vim was previously exited
|``|	   ``		go to the position before the last jump
|`quote|   `"		go to the position when last editing this file
|`[|	   `[		go to the start of the previously operated or put text
|`]|	   `]		go to the end of the previously operated or put text
|`<|	   `<		go to the start of the (previous) Visual area
|`>|	   `>		go to the end of the (previous) Visual area
|'|	   '{a-zA-Z0-9[]'"<>}
			same as `, but on the first non-blank in the line
|:marks|  :marks	print the active marks
|CTRL-O|  N  CTRL-O	go to Nth older position in jump list
|CTRL-I|  N  CTRL-I	go to Nth newer position in jump list
|:ju|	  :ju[mps]	print the jump list
------------------------------------------------------------------------------
*X_vm*		Various motions

|%|	   %		find the next brace, bracket, comment, or "#if"/
			   "#else"/"#endif" in this line and go to its match
|H|	N  H		go to the Nth line in the window, on the first
			   non-blank
|M|	   M		go to the middle line in the window, on the first
			   non-blank
|L|	N  L		go to the Nth line from the bottom, on the first
			   non-blank

|go|	N  go			go to Nth byte in the buffer
|:go|	:[range]go[to] [off]	go to [off] byte in the buffer
------------------------------------------------------------------------------
*X_ta*		Using tags

|:ta|	   :ta[g][!] {tag}	Jump to tag {tag}
|:ta|	   :[count]ta[g][!]	Jump to [count]'th newer tag in tag list
|CTRL-]|      CTRL-]		Jump to the tag under cursor, unless changes
				   have been made
|:ts|	   :ts[elect][!] [tag]	List matching tags and select one to jump to
|:tjump|   :tj[ump][!] [tag]	Jump to tag [tag] or select from list when
				   there are multiple matches

|:tags|	   :tags		Print tag list
|CTRL-T|   N  CTRL-T		Jump back from Nth older tag in tag list
|:po|	   :[count]po[p][!]	Jump back from [count]'th older tag in tag list
|:tnext|   :[count]tn[ext][!]	Jump to [count]'th next matching tag
|:tp|      :[count]tp[revious][!] Jump to [count]'th previous matching tag
|:tr|	   :[count]tr[ewind][!] Jump to [count]'th matching tag
|:tl|	   :tl[ast][!]		Jump to last matching tag

|:ptag|	   :pt[ag] {tag}	open a preview window to show tag {tag}
|CTRL-W_}|     CTRL-W }		like CTRL-] but show tag in preview window
|:pts|     :pts[elect]		like ":tselect" but show tag in preview window
|:ptjump|  :ptj[ump]		like ":tjump" but show tag in preview window
|:pclose|  :pc[lose]		close tag preview window
|CTRL-W_z|     CTRL-W z		close tag preview window
------------------------------------------------------------------------------
*X_sc*		Scrolling

|CTRL-E|	N  CTRL-E	window N lines downwards (default: 1)
|CTRL-D|	N  CTRL-D	window N lines Downwards (default: 1/2 window)
|CTRL-F|	N  CTRL-F	window N pages Forwards (downwards)
|CTRL-Y|	N  CTRL-Y	window N lines upwards (default: 1)
|CTRL-U|	N  CTRL-U	window N lines Upwards (default: 1/2 window)
|CTRL-B|	N  CTRL-B	window N pages Backwards (upwards)
|z<CR>|		   z<CR> or zt	redraw, current line at top of window
|z.|		   z.	 or zz	redraw, current line at center of window
|z-|		   z-	 or zb	redraw, current line at bottom of window

These only work when 'wrap' is off:
|zh|		N  zh		scroll screen N characters to the right
|zl|		N  zl		scroll screen N characters to the left
|zH|		N  zH		scroll screen half a screenwidth to the right
|zL|		N  zL		scroll screen half a screenwidth to the left
------------------------------------------------------------------------------
*X_in*		Inserting text

|a|	N  a	append text after the cursor (N times)
|A|	N  A	append text at the end of the line (N times)
|i|	N  i	insert text before the cursor (N times) (also: <Insert>)
|I|	N  I	insert text before the first non-blank in the line (N times)
|gI|	N  gI	insert text in column 1 (N times)
|o|	N  o	open a new line below the current line, append text (N times)
|O|	N  O	open a new line above the current line, append text (N times)
|:startinsert|  :star[tinsert][!]  start Insert mode, append when [!] used

in Visual block mode:
|v_b_I|    I	insert the same text in front of all the selected lines
|v_b_A|	   A	append the same text after all the selected lines
------------------------------------------------------------------------------
*X_ai*		Insert mode keys

|insert-index|	alphabetical index of Insert mode commands

leaving Insert mode:
|i_<Esc>|	<Esc>		  end Insert mode, back to Normal mode
|i_CTRL-C|	CTRL-C		  like <Esc>, but do not use an abbreviation
|i_CTRL-O|	CTRL-O {command}  execute {command} and return to Insert mode

moving around:
|i_<Up>|	cursor keys	  move cursor left/right/up/down
|i_<S-Left>|	shift-left/right  one word left/right
|i_<S-Up>|	shift-up/down	  one screenful backward/forward
|i_<End>|	<End>		  cursor after last character in the line
|i_<Home>|	<Home>		  cursor to first character in the line
------------------------------------------------------------------------------
*X_ss*		Special keys in Insert mode

|i_CTRL-V|	CTRL-V {char}..	  insert character literally, or enter decimal
				     byte value
|i_<NL>|	<NL> or <CR> or CTRL-M or CTRL-J
				  begin new line
|i_CTRL-E|	CTRL-E		  insert the character from below the cursor
|i_CTRL-Y|	CTRL-Y		  insert the character from above the cursor

|i_CTRL-A|	CTRL-A		  insert previously inserted text
|i_CTRL-@|	CTRL-@		  insert previously inserted text and stop
				     Insert mode
|i_CTRL-R|	CTRL-R {0-9a-z%#:.-="}  insert the contents of a register

|i_CTRL-N|	CTRL-N		  insert next match of identifier before the
				     cursor
|i_CTRL-P|	CTRL-P		  insert previous match of identifier before
				     the cursor
|i_CTRL-X|	CTRL-X ...	  complete the word before the cursor in
				     various ways

|i_<BS>|	<BS> or CTRL-H	  delete the character before the cursor
|i_<Del>|	<Del>		  delete the character under the cursor
|i_CTRL-W|	CTRL-W		  delete word before the cursor
|i_CTRL-U|	CTRL-U		  delete all entered characters in the current
				     line
|i_CTRL-T|	CTRL-T		  insert one shiftwidth of indent in front of
				       the current line
|i_CTRL-D|	CTRL-D		  delete one shiftwidth of indent in front of
				     the current line
|i_0_CTRL-D|	0 CTRL-D	  delete all indent in the current line
|i_^_CTRL-D|	^ CTRL-D	  delete all indent in the current line,
				     restore indent in next line
------------------------------------------------------------------------------
*X_di*		Digraphs

|:dig|	   :dig[raphs]		show current list of digraphs
|:dig|	   :dig[raphs] {char1}{char2} {number} ...
				add digraph(s) to the list

In Insert or Command-line mode:
|i_CTRL-K|	CTRL-K {char1} {char2}
				  enter digraph
|i_digraph|	{char1} <BS> {char2}
				  enter digraph if 'digraph' option set
------------------------------------------------------------------------------
*X_si*		Special inserts

|:r|	   :r [file]	   insert the contents of [file] below the cursor
|:r!|	   :r! {command}   insert the standard output of {command} below the
			      cursor
------------------------------------------------------------------------------
*X_de*		Deleting text

|x|	N  x		delete N characters under and after the cursor
|<Del>| N  <Del>	delete N characters under and after the cursor
|X|	N  X		delete N characters before the cursor
|d|	N  d{motion}	delete the text that is moved over with {motion}
|v_d|	{visual}d	delete the highlighted text
|dd|	N  dd		delete N lines
|D|	N  D		delete to the end of the line (and N-1 more lines)
|J|	N  J		join N-1 lines (delete <EOL>s)
|v_J|	{visual}J	join the highlighted lines
|gJ|	N  gJ		like "J", but without inserting spaces
|v_gJ|	{visual}gJ	like "{visual}J", but without inserting spaces
|:d|	:[range]d [x]	delete [range] lines [into register x]
------------------------------------------------------------------------------
*X_cm*		Copying and moving text

|quote|	  "{char}	use register {char} for the next delete, yank, or put
|:reg|	  :reg		show the contents of all registers
|:reg|	  :reg {arg}	show the contents of registers mentioned in {arg}
|y|	  N  y{motion}	yank the text moved over with {motion} into a register
|v_y|	     {visual}y	yank the highlighted text into a register
|yy|	  N  yy		yank N lines into a register
|Y|	  N  Y		yank N lines into a register
|p|	  N  p		put a register after the cursor position (N times)
|P|	  N  P		put a register before the cursor position (N times)
|]p|	  N  ]p		like p, but adjust indent to current line
|[p|	  N  [p		like P, but adjust indent to current line
|gp|	  N  gp		like p, but leave cursor after the new text
|gP|	  N  gP		like P, but leave cursor after the new text
------------------------------------------------------------------------------
*X_ch*		Changing text

|r|	  N  r{char}	replace N characters with {char}
|gr|	  N  gr{char}	replace N characters without affecting layout
|R|	  N  R		enter Replace mode (repeat the entered text N times)
|gR|	  N  gR		enter virtual Replace mode: Like Replace mode but
			   without affecting layout
|v_b_r|	  {visual}r{char}
			in Visual block mode: Replace each char of the
			   selected text with {char}

	(change = delete text and enter Insert mode)
|c|	  N  c{motion}	change the text that is moved over with {motion}
|v_c|	     {visual}c	change the highlighted text
|cc|	  N  cc		change N lines
|S|	  N  S		change N lines
|C|	  N  C		change to the end of the line (and N-1 more lines)
|s|	  N  s		change N characters
|v_b_c|	     {visual}c	in Visual block mode: Change each of the selected
			   lines with the entered text
|v_b_C|	     {visual}C	in Visual block mode: Change each of the selected
			   lines until end-of-line with the entered text

|~|	  N  ~		switch case for N characters and advance cursor
|v_~|	     {visual}~	switch case for highlighted text
|v_u|	     {visual}u	make highlighted text lowercase
|v_U|	     {visual}U	make highlighted text uppercase
|g~|	     g~{motion} switch case for the text that is moved over with
			   {motion}
|gu|	     gu{motion} make the text that is moved over with {motion}
			   lowercase
|gU|	     gU{motion} make the text that is moved over with {motion}
			   uppercase
|v_g?|	     {visual}g? perform rot13 encoding on highlighted text
|g?|	     g?{motion} perform rot13 encoding on the text that is moved over
			   with {motion}

|CTRL-A|  N  CTRL-A	add N to the number at or after the cursor
|CTRL-X|  N  CTRL-X	subtract N from the number at or after the cursor

|<|	  N  <{motion}	move the lines that are moved over with {motion} one
			   shiftwidth left
|<<|	  N  <<		move N lines one shiftwidth left
|>|	  N  >{motion}	move the lines that are moved over with {motion} one
			   shiftwidth right
|>>|	  N  >>		move N lines one shiftwidth right
|gq|	  N  gq{motion}	format the lines that are moved over with {motion} to
			   'textwidth' length
|:ce|	  :[range]ce[nter] [width]
			center the lines in [range]
|:le|	  :[range]le[ft] [indent]
			left-align the lines in [range] (with [indent])
|:ri|	  :[range]ri[ght] [width]
			right-align the lines in [range]
------------------------------------------------------------------------------
*X_co*		Complex changes

|!|	   N  !{motion}{command}<CR>
			filter the lines that are moved over through {command}
|!!|	   N  !!{command}<CR>
			filter N lines through {command}
|v_!|	      {visual}!{command}<CR>
			filter the highlighted lines through {command}
|:range!|  :[range]! {command}<CR>
			filter [range] lines through {command}
|=|	   N  ={motion}
			filter the lines that are moved over through 'equalprg'
|==|	   N  ==	filter N lines through 'equalprg'
|v_=|	      {visual}=
			filter the highlighted lines through 'equalprg'
|:s|	   :[range]s[ubstitute]/{pattern}/{string}/[g][c]
			substitute {pattern} by {string} in [range] lines;
			   with [g], replace all occurrences of {pattern};
			   with [c], confirm each replacement
|:s|	   :[range]s[ubstitute] [g][c]
			repeat previous ":s" with new range and options
|&|	      &		Repeat previous ":s" on current line without options
|:ret|	   :[range]ret[ab][!] [tabstop]
			set 'tabstop' to new value and adjust white space
			   accordingly
------------------------------------------------------------------------------
*X_vi*		Visual mode

|visual-index|	list of Visual mode commands.

|v|	   v		start highlighting characters  }  move cursor and use
|V|	   V		start highlighting linewise    }  operator to affect
|CTRL-V|   CTRL-V	start highlighting blockwise   }  highlighted text
|v_o|	   o		exchange cursor position with start of highlighting
|gv|	   gv		start highlighting on previous visual area
|v_v|	   v		highlight characters or stop highlighting
|v_V|	   V		highlight linewise or stop highlighting
|v_CTRL-V| CTRL-V	highlight blockwise or stop highlighting
------------------------------------------------------------------------------
*X_to*		Text objects (only in Visual mode or after an operator)

|v_aw|	N  aw		Select "a word"
|v_iw|	N  iw		Select "inner word"
|v_aW|	N  aW		Select "a WORD"
|v_iW|	N  iW		Select "inner WORD"
|v_as|	N  as		Select "a sentence"
|v_is|	N  is		Select "inner sentence"
|v_ap|	N  ap		Select "a paragraph"
|v_ip|	N  ip		Select "inner paragraph"
|v_ab|	N  ab		Select "a block" (from "[(" to "])")
|v_ib|	N  ib		Select "inner block" (from "[(" to "])")
|v_aB|	N  aB		Select "a Block" (from "[{" to "]}")
|v_iB|	N  iB		Select "inner Block" (from "[{" to "]}")
------------------------------------------------------------------------------
*X_re*		Repeating commands

|.|	   N  .		repeat last change (with count replaced with N)
|q|	      q{a-z}	record typed characters into register {a-z}
|q|	      q{A-Z}	record typed characters, appended to register {a-z}
|q|	      q		stop recording
|@|	   N  @{a-z}	execute the contents of register {a-z} (N times)
|@@|	   N  @@	   repeat previous @{a-z} (N times)
|:@|	   :@{a-z}	execute the contents of register {a-z} as an Ex
			   command
|:@@|	   :@@		repeat previous :@{a-z}
|:g|	   :[range]g[lobal]/{pattern}/[cmd]
			Execute Ex command [cmd] (default: ":p") on the lines
			   within [range] where {pattern} matches.
|:g|	   :[range]g[lobal]!/{pattern}/[cmd]
			Execute Ex command [cmd] (default: ":p") on the lines
			   within [range] where {pattern} does NOT match.
|:so|	   :so[urce] {file}
			Read Ex commands from {file}.
|:so|	   :so[urce]! {file}
			Read Vim commands from {file}.
|:sl|	   :sl[eep] [sec]
			don't do anything for [sec] seconds
|gs|	   N  gs	Goto Sleep for N seconds
------------------------------------------------------------------------------
*X_km*		Key mapping

|:map|	     :ma[p] {lhs} {rhs}	  Map {lhs} to {rhs} in Normal and Visual
				     mode.
|:map!|	     :ma[p]! {lhs} {rhs}  Map {lhs} to {rhs} in Insert and Command-line
				     mode.
|:noremap|   :no[remap][!] {lhs} {rhs}
				  Same as ":map", no remapping for this {rhs}
|:unmap|     :unm[ap] {lhs}	  Remove the mapping of {lhs} for Normal and
				     Visual mode.
|:unmap!|    :unm[ap]! {lhs}	  Remove the mapping of {lhs} for Insert and
				     Command-line mode.
|:map_l|     :ma[p] [lhs]	  List mappings (starting with [lhs]) for
				     Normal and Visual mode.
|:map_l!|    :ma[p]! [lhs]	  List mappings (starting with [lhs]) for
				     Insert and Command-line mode.
|:cmap|	     :cmap/:cunmap/:cnoremap
				  like ":map!"/":unmap!"/":noremap!" but for
				     Command-line mode only
|:imap|	     :imap/:iunmap/:inoremap
				  like ":map!"/":unmap!"/":noremap!" but for
				     Insert mode only
|:nmap|	     :nmap/:nunmap/:nnoremap
				  like ":map"/":unmap"/":noremap" but for
				     Normal mode only
|:vmap|	     :vmap/:vunmap/:vnoremap
				  like ":map"/":unmap"/":noremap" but for
				     Visual mode only
|:omap|	     :omap/:ounmap/:onoremap
				  like ":map"/":unmap"/":noremap" but only for
				     when an operator is pending
|:mapc|      :mapc[lear]	  remove mappings for Normal and Visual mode
|:mapc|      :mapc[lear]!	  remove mappings for Insert and Cmdline mode
|:imapc|     :imapc[lear]	  remove mappings for Insert mode
|:vmapc|     :vmapc[lear]	  remove mappings for Visual mode
|:omapc|     :omapc[lear]	  remove mappings for Operator-pending mode
|:nmapc|     :nmapc[lear]	  remove mappings for Normal mode
|:cmapc|     :cmapc[lear]	  remove mappings for Cmdline mode
|:mkexrc|    :mk[exrc][!] [file]  write current mappings, abbreviations, and
				     settings to [file] (default: ".exrc";
				     use ! to overwrite)
|:mkvimrc|   :mkv[imrc][!] [file]
				  same as ":mkexrc", but with default ".vimrc"
|:mksession| :mks[ession][!] [file]
				  like ":mkvimrc", but store current files,
				     windows, etc. too, to be able to continue
				     this session later.
------------------------------------------------------------------------------
*X_ab*		Abbreviations

|:abbreviate|	:ab[breviate] {lhs} {rhs}  add abbreviation for {lhs} to {rhs}
|:abbreviate|	:ab[breviate] {lhs}	   show abbr's that start with {lhs}
|:abbreviate|	:ab[breviate]		   show all abbreviations
|:unabbreviate|	:una[bbreviate] {lhs}	   remove abbreviation for {lhs}
|:noreabbrev|	:norea[bbrev] [lhs] [rhs]  like ":ab", but don't remap [rhs]
|:iabbrev|	:iab/:iunab/:inoreab	   like ":ab", but only for Insert mode
|:cabbrev|	:cab/:cunab/:cnoreab	   like ":ab", but only for
						Command-line mode
|:abclear|	:abc[lear]		   remove all abbreviations
|:cabclear|	:cabc[lear]		   remove all abbr's for Cmdline mode
|:iabclear|	:iabc[lear]		   remove all abbr's for Insert mode
------------------------------------------------------------------------------
*X_op*		Options

|:set|	:se[t]			Show all modified options.
|:set|	:se[t] all		Show all options.
|:set|	:se[t] {option}		Set boolean option (switch it on), show string
				   or number option.
|:set|	:se[t] no{option}	Reset boolean option (switch it off).
|:set|	:se[t] inv{option}	invert boolean option.
|:set|	:se[t] {option}={value} Set string or number option to {value}.
|:set|	:se[t] {option}+={value} append {value} to string option, add {value}
				to number option
|:set|	:se[t] {option}-={value} remove {value} to string option, subtract
				{value} from number option
|:set|	:se[t] {option}?	Show value of {option}.
|:set|	:se[t] {option}&	Reset {option} to its default value.

|:fix|	:fix[del]		Set value of 't_kD' according to value of
				   't_kb'.
|:options|  :opt[ions]		Open a new window to view and set options,
				grouped by functionality and with short help

Short explanation of each option:		*option-list*
|'aleph'|	   |'al'|	ASCII code of the letter Aleph (Hebrew)
|'allowrevins'|	   |'ari'|	allow CTRL-_ in Insert and Command-line mode
|'altkeymap'|	   |'akm'|	for default second language (Farsi/Hebrew)
|'autoindent'|	   |'ai'|	take indent for new line from previous line
|'autowrite'|	   |'aw'|	automatically write file if changed
|'background'|	   |'bg'|	"dark" or "light", used for highlight colors
|'backspace'|	   |'bs'|	how backspace works at start of line
|'backup'|	   |'bk'|	keep backup file after overwriting a file
|'backupdir'|	   |'bdir'|	list of directories for the backup file
|'backupext'|	   |'bex'|	extension used for the backup file
|'binary'|	   |'bin'|	read/write/edit file in binary mode
|'bioskey'|	   |'biosk'|	MS-DOS: use bios calls for input characters
|'breakat'|	   |'brk'|	characters that may cause a line break
|'browsedir'|	   |'bsdir'|	which directory to start browsing in
|'cindent'|	   |'cin'|	do C program indenting
|'cinkeys'|	   |'cink'|	keys that trigger indent when 'cindent' is set
|'cinoptions'|	   |'cino'|	how to do indenting when 'cindent' is set
|'cinwords'|	   |'cinw'|	words where 'si' and 'cin' add an indent
|'clipboard'|	   |'cb'|	use the clipboard as the unnamed register
|'cmdheight'|	   |'ch'|	number of lines to use for the command-line
|'columns'|	   |'co'|	number of columns in the display
|'comments'|	   |'com'|	patterns that can start a comment line
|'compatible'|	   |'cp'|	behave Vi-compatible as much as possible
|'complete'|	   |'cpt'|	specify how Insert mode completion works
|'confirm'|	   |'cf'|	ask what to do about unsaved/read-only files
|'conskey'|	   |'consk'|	get keys directly from console (MS-DOS only)
|'cpoptions'|	   |'cpo'|	flags for Vi-compatible behavior
|'cscopeprg'|	   |'csprg'|	command to execute cscope
|'cscopetag'|	   |'cst'|	use cscope for tag commands
|'cscopetagorder'| |'csto'|	determines ":cstag" search order
|'cscopeverbose'|  |'csverb'|	give messages when adding a cscope database
|'define'|	   |'def'|	pattern to be used to find a macro definition
|'dictionary'|	   |'dict'|	list of file names used for keyword completion
|'digraph'|	   |'dg'|	enable the entering of digraphs in Insert mode
|'directory'|	   |'dir'|	list of directory names for the swap file
|'display'|	   |'dy'|	list of flags for how to display text
|'edcompatible'|   |'ed'|	toggle flags of ":substitute" command
|'endofline'|	   |'eol'|	write <EOL> for last line in file
|'equalalways'|    |'ea'|	windows are automatically made the same size
|'equalprg'|	   |'ep'|	external program to use for "=" command
|'errorbells'|	   |'eb'|	ring the bell for error messages
|'errorfile'|	   |'ef'|	name of the errorfile for the QuickFix mode
|'errorformat'|    |'efm'|	description of the lines in the error file
|'esckeys'|	   |'ek'|	recognize function keys in Insert mode
|'eventignore'|	   |'ei'|	autocommand events that are ignored
|'expandtab'|	   |'et'|	use spaces when <Tab> is inserted
|'exrc'|	   |'ex'|	read .vimrc and .exrc in the current directory
|'fileencoding'|   |'fe'|	file encoding for multi-byte text
|'fileformat'|	   |'ff'|	file format used for file I/O
|'fileformats'|	   |'ffs'|	automatically detected values for 'fileformat'
|'filetype'|	   |'ft'|	type of file, used for autocommands
|'fkmap'|	   |'fk'|	Farsi keyboard mapping
|'formatoptions'|  |'fo'|	how automatic formatting is to be done
|'formatprg'|	   |'fp'|	name of external program used with "gq" command
|'gdefault'|	   |'gd'|	the ":substitute" flag 'g' is default on
|'grepformat'|	   |'gfm'|	format of 'grepprg' output
|'grepprg'|	   |'gp'|	program to use for ":grep"
|'guicursor'|	   |'gcr'|	GUI: settings for cursor shape and blinking
|'guifont'|	   |'gfn'|	GUI: Name(s) of font(s) to be used
|'guifontset'|	   |'gfs'|	GUI: Names of multi-byte fonts to be used
|'guiheadroom'|	   |'ghr'|	GUI: pixels room for window decorations
|'guioptions'|	   |'go'|	GUI: Which components and options are used
|'guipty'|			GUI: try to use a pseudo-tty for ":!" commands
|'helpfile'|	   |'hf'|	name of this help file
|'helpheight'|	   |'hh'|	minimum height of a new help window
|'hidden'|	   |'hid'|	don't unload buffer when it is |abandon|ed
|'highlight'|	   |'hl'|	sets highlighting mode for various occasions
|'hlsearch'|	   |'hls'|	highlight matches with last search pattern
|'history'|	   |'hi'|	number of command-lines that are remembered
|'hkmap'|	   |'hk'|	Hebrew keyboard mapping
|'hkmapp'|	   |'hkp'|	phonetic Hebrew keyboard mapping
|'icon'|			let Vim set the text of the window icon
|'iconstring'|			string to use for the Vim icon text
|'ignorecase'|	   |'ic'|	ignore case in search patterns
|'include'|	   |'inc'|	pattern to be used to find an include file
|'incsearch'|	   |'is'|	highlight match while typing search pattern
|'infercase'|	   |'inf'|	adjust case of match for keyword completion
|'insertmode'|	   |'im'|	start the edit of a file in Insert mode
|'isfname'|	   |'isf'|	characters included in file names and pathnames
|'isident'|	   |'isi'|	characters included in identifiers
|'iskeyword'|	   |'isk'|	characters included in keywords
|'isprint'|	   |'isp'|	printable characters
|'joinspaces'|	   |'js'|	two spaces after a period with a join command
|'key'|				encryption key
|'keymodel'|	   |'km'|	enable starting/stopping selection with keys
|'keywordprg'|	   |'kp'|	program to use for the "K" command
|'langmap'|	   |'lmap'|	alphabetic characters for other language mode
|'laststatus'|	   |'ls'|	tells when last window has status lines
|'lazyredraw'|	   |'lz'|	don't redraw while executing macros
|'linebreak'|	   |'lbr'|	wrap long lines at a blank
|'lines'|			number of lines in the display
|'lisp'|			automatic indenting for Lisp
|'list'|			show <Tab> and <EOL>
|'listchars'|	   |'lcs'|	characters for displaying in list mode
|'magic'|			changes special characters in search patterns
|'makeef'|	   |'mef'|	name of the errorfile for ":make"
|'makeprg'|	   |'mp'|	program to use for the ":make" command
|'matchpairs'|	   |'mps'|	pairs of characters that "%" can match
|'matchtime'|	   |'mat'|	tenths of a second to show matching paren
|'maxfuncdepth'|   |'mfd'|	maximum recursive depth for user functions
|'maxmapdepth'|    |'mmd'|	maximum recursive depth for mapping
|'maxmem'|	   |'mm'|	maximum memory (in Kbyte) used for one buffer
|'maxmemtot'|	   |'mmt'|	maximum memory (in Kbyte) used for all buffers
|'modeline'|	   |'ml'|	recognize modelines at start or end of file
|'modelines'|	   |'mls'|	number of lines checked for modelines
|'modified'|	   |'mod'|	buffer has been modified
|'more'|			pause listings when the whole screen is filled
|'mouse'|			enable the use of mouse clicks
|'mousefocus'|	   |'mousef'|	keyboard focus follows the mouse
|'mousehide'|	   |'mh'|	hide mouse pointer while typing
|'mousemodel'|	   |'mousem'|	changes meaning of mouse buttons
|'mousetime'|	   |'mouset'|	max time between mouse double-click
|'nrformats'|	   |'nf'|	number formats recognized for CTRL-A command
|'number'|	   |'nu'|	print the line number in front of each line
|'osfiletype'|	   |'oft'|	operating system-specific filetype information
|'paragraphs'|	   |'para'|	nroff macros that separate paragraphs
|'paste'|			allow pasting text
|'pastetoggle'|	   |'pt'|	key code that causes 'paste' to toggle
|'patchmode'|	   |'pm'|	keep the oldest version of a file
|'path'|	   |'pa'|	list of directories searched with "gf" et.al.
|'previewheight'|  |'pvh'|	height of the preview window
|'readonly'|	   |'ro'|	disallow writing the buffer
|'remap'|			allow mappings to work recursively
|'report'|			threshold for reporting nr. of lines changed
|'restorescreen'|  |'rs'|	Win32: restore screen when exiting
|'revins'|	   |'ri'|	inserting characters will work backwards
|'rightleft'|	   |'rl'|	window is right-to-left oriented
|'ruler'|	   |'ru'|	show cursor line and column in the status line
|'rulerformat'|	   |'ruf'|	custom format for the ruler
|'scroll'|	   |'scr'|	lines to scroll with CTRL-U and CTRL-D
|'scrollbind'|	   |'scb'|	scroll in window as other windows scroll
|'scrolljump'|	   |'sj'|	minimum number of lines to scroll
|'scrolloff'|	   |'so'|	minimum nr. of lines above and below cursor
|'scrollopt'|	   |'sbo'|	how 'scrollbind' should behave
|'sections'|	   |'sect'|	nroff macros that separate sections
|'secure'|			secure mode for reading .vimrc in current dir
|'selection'|	   |'sel'|	what type of selection to use
|'selectmode'|	   |'slm'|	when to use Select mode instead of Visual mode
|'sessionoptions'| |'ssop'|	options for |:mksession|
|'shell'|	   |'sh'|	name of shell to use for external commands
|'shellcmdflag'|   |'shcf'|	flag to shell to execute one command
|'shellpipe'|	   |'sp'|	string to put output of ":make" in error file
|'shellquote'|	   |'shq'|	quote character(s) for around shell command
|'shellredir'|	   |'srr'|	string to put output of filter in a temp file
|'shellslash'|	   |'ssl'|	use forward slash for shell file names
|'shelltype'|	   |'st'|	Amiga: influences how to use a shell
|'shellxquote'|	   |'sxq'|	like 'shellquote', but include redirection
|'shiftround'|	   |'sr'|	round indent to multiple of shiftwidth
|'shiftwidth'|	   |'sw'|	number of spaces to use for (auto)indent step
|'shortmess'|	   |'shm'|	list of flags, reduce length of messages
|'shortname'|	   |'sn'|	non-MS-DOS: Filenames assumed to be 8.3 chars
|'showbreak'|	   |'sbr'|	string to use at the start of wrapped lines
|'showcmd'|	   |'sc'|	show (partial) command in status line
|'showfulltag'|	   |'sft'|	show full tag pattern when completing tag
|'showmatch'|	   |'sm'|	briefly jump to matching bracket if insert one
|'showmode'|	   |'smd'|	message on status line to show current mode
|'sidescroll'|	   |'ss'|	minimum number of columns to scroll horizontal
|'smartcase'|	   |'scs'|	no ignore case when pattern has uppercase
|'smartindent'|    |'si'|	smart autoindenting for C programs
|'smarttab'|	   |'sta'|	use 'shiftwidth' when inserting <Tab>
|'softtabstop'|	   |'sts'|	number of spaces that <Tab> uses while editing
|'splitbelow'|	   |'sb'|	new window from split is below the current one
|'startofline'|    |'sol'|	commands move cursor to first blank in line
|'statusline'|	   |'stl'|	custom format for the status line
|'suffixes'|	   |'su'|	suffixes that are ignored with multiple match
|'swapfile'|	   |'swf'|	whether to use a swapfile for a buffer
|'swapsync'|	   |'sws'|	how to sync the swap file
|'switchbuf'|	   |'swb'|	sets behavior when switching to another buffer
|'syntax'|	   |'syn'|	syntax to be loaded for current buffer
|'tabstop'|	   |'ts'|	number of spaces that <Tab> in file uses
|'tagbsearch'|	   |'tbs'|	use binary searching in tags files
|'taglength'|	   |'tl'|	number of significant characters for a tag
|'tagrelative'|    |'tr'|	file names in tag file are relative
|'tags'|	   |'tag'|	list of file names used by the tag command
|'tagstack'|	   |'tgst'|	push tags onto the tag stack
|'term'|			name of the terminal
|'terse'|			shorten some messages
|'textauto'|	   |'ta'|	obsolete, use 'fileformats'
|'textmode'|	   |'tx'|	obsolete, use 'fileformat'
|'textwidth'|	   |'tw'|	maximum width of text that is being inserted
|'tildeop'|	   |'top'|	tilde command "~" behaves like an operator
|'timeout'|	   |'to'|	time out on mappings and key codes
|'timeoutlen'|	   |'tm'|	time out time in milliseconds
|'title'|			let Vim set the title of the window
|'titlelen'|			percentage of 'columns' used for window title
|'titleold'|			old title, restored when exiting
|'titlestring'|			string to use for the Vim window title
|'toolbar'|	   |'tb'|	GUI: which items to show in the toolbar
|'ttimeout'|			time out on mappings
|'ttimeoutlen'|	   |'ttm'|	time out time for key codes in milliseconds
|'ttybuiltin'|	   |'tbi'|	use built-in termcap before external termcap
|'ttyfast'|	   |'tf'|	indicates a fast terminal connection
|'ttymouse'|	   |'ttym'|	type of mouse codes generated
|'ttyscroll'|	   |'tsl'|	maximum number of lines for a scroll
|'ttytype'|	   |'tty'|	alias for 'term'
|'undolevels'|	   |'ul'|	maximum number of changes that can be undone
|'updatecount'|    |'uc'|	after this many characters flush swap file
|'updatetime'|	   |'ut'|	after this many milliseconds flush swap file
|'verbose'|	   |'vbs'|	give informative messages
|'viminfo'|	   |'vi'|	use .viminfo file upon startup and exiting
|'visualbell'|	   |'vb'|	use visual bell instead of beeping
|'warn'|			warn for shell command when buffer was changed
|'weirdinvert'|    |'wi'|	for terminals that have weird inversion method
|'whichwrap'|	   |'ww'|	allow specified keys to cross line boundaries
|'wildchar'|	   |'wc'|	command-line character for wildcard expansion
|'wildcharm'|	   |'wcm'|	like 'wildchar' but also works when mapped
|'wildignore'|	   |'wig'|	files matching these patterns are not completed
|'wildmenu'|	   |'wmnu'|	use menu for command line completion
|'wildmode'|	   |'wim'|	mode for 'wildchar' command-line expansion
|'winaltkeys'|	   |'wak'|	when the windows system handles ALT keys
|'winheight'|	   |'wh'|	minimum number of lines for the current window
|'winminheight'|   |'wmh'|	minimum number of lines for any window
|'wrap'|			long lines wrap and continue on the next line
|'wrapmargin'|	   |'wm'|	chars from the right where wrapping starts
|'wrapscan'|	   |'ws'|	searches wrap around the end of the file
|'write'|			writing to a file is allowed
|'writeany'|	   |'wa'|	write to file with no need for "!" override
|'writebackup'|    |'wb'|	make a backup before overwriting a file
|'writedelay'|	   |'wd'|	delay this many msec for each char (for debug)
------------------------------------------------------------------------------
*X_ur*		Undo/Redo commands

|u|	  N  u		undo last N changes
|CTRL-R|  N  CTRL-R	redo last N undone changes
|U|	     U		restore last changed line
------------------------------------------------------------------------------
*X_et*		External commands

|:shell|	:sh[ell]	start a shell
|:!|		:!{command}	execute {command} with a shell
|K|		   K		lookup keyword under the cursor with
				   'keywordprg' program (default: "man")
------------------------------------------------------------------------------
*X_qf*		Quickfix commands

|:cc|		:cc [nr]	display error [nr] (default is the same again)
|:cnext|	:cn		display the next error
|:cprevious|	:cp		display the previous error
|:clist|	:cl		list all errors
|:cfile|	:cf		read errors from the file 'errorfile'
|:cquit|	:cq		quit without writing and return error code (to
				   the compiler)
|:make|		:make [args]	start make, read errors, and jump to first
				   error
|:grep|		:gr[ep] [args]	execute 'grepprg' to find matches and jump to
				   the first one.
------------------------------------------------------------------------------
*X_vc*		Various commands

|CTRL-L|	   CTRL-L	Clear and redraw the screen.
|CTRL-G|	   CTRL-G	show current file name (with path) and cursor
				   position
|ga|		   ga		show ascii value of character under cursor in
				   decimal, hex, and octal
|g_CTRL-G|	   g CTRL-G	show cursor column, line, and character
				   position
|CTRL-C|	   CTRL-C	during searches: Interrupt the search
|dos-CTRL-Break|   CTRL-Break	MS-DOS: during searches: Interrupt the search
|<Del>|		   <Del>	while entering a count: delete last character
|:version|	:ve[rsion]	show version information
|:mode|		:mode N		MS-DOS: set screen mode to N (number, C80,
				   C4350, etc.)
|:normal|	:norm[al][!] {commands}
				Execute Normal mode commands.
|Q|		Q		switch to "Ex" mode
|:redir|	:redir >{file}	redirect messages to {file}
|:confirm|	:confirm {command}	quit, write, etc., asking about
				   unsaved changes or read-only files.
------------------------------------------------------------------------------
*X_ce*		Command-line editing

|c_<Esc>|	<Esc>		   abandon command-line (if 'wildchar' is
				      <Esc>, type it twice)

|c_CTRL-V|	CTRL-V {char}	   insert {char} literally
|c_CTRL-V|	CTRL-V {number}    enter decimal value of character (up to
				      three digits)
|c_CTRL-K|	CTRL-K {char1} {char2}
				   enter digraph (See |X_di|)
|c_CTRL-R|	CTRL-R {0-9a-z"%#:-=}
				   insert the contents of a register

|c_<Left>|	<Left>/<Right>	   cursor left/right
|c_<S-Left>|	<S-Left>/<S-Right> cursor one word left/right
|c_CTRL-B|	CTRL-B/CTRL-E	   cursor to beginning/end of command-line

|c_<BS>|	<BS>		   delete the character in front of the cursor
|c_<Del>|	<Del>		   delete the character under the cursor
|c_CTRL-W|	CTRL-W		   delete the word in front of the cursor
|c_CTRL-U|	CTRL-U		   remove all characters

|c_<Up>|	<Up>/<Down>	   recall older/newer command-line that starts
				      with current command
|c_<S-Up>|	<S-Up>/<S-Down>	   recall older/newer command-line from history
|:history|	:his[tory]	   show older command-lines

Context-sensitive completion on the command-line:

|c_wildchar|	'wildchar'  (default: <Tab>)
				do completion on the pattern in front of the
				   cursor.  If there are multiple matches,
				   beep and show the first one; further
				   'wildchar' will show the next ones.
|c_CTRL-D|	CTRL-D		list all names that match the pattern in
				   front of the cursor
|c_CTRL-A|	CTRL-A		insert all names that match pattern in front
				   of cursor
|c_CTRL-L|	CTRL-L		insert longest common part of names that
				   match pattern
|c_CTRL-N|	CTRL-N		after 'wildchar' with multiple matches: go
				   to next match
|c_CTRL-P|	CTRL-P		after 'wildchar' with multiple matches: go
				   to previous match
------------------------------------------------------------------------------
*X_ra*		Ex ranges

|:range|	,		separates two line numbers
|:range|	;		idem, set cursor to the first line number
				before interpreting the second one

|:range|	{number}	an absolute line number
|:range|	.		the current line
|:range|	$		the last line in the file
|:range|	%		equal to 1,$ (the entire file)
|:range|	*		equal to '<,'> (visual area)
|:range|	't		position of mark t
|:range|	/{pattern}[/]	the next line where {pattern} matches
|:range|	?{pattern}[?]	the previous line where {pattern} matches

|:range|	+[num]		add [num] to the preceding line number
				   (default: 1)
|:range|	-[num]		subtract [num] from the preceding line
				   number (default: 1)
------------------------------------------------------------------------------
*X_ex*		Special Ex characters

|:bar|	    |		separates two commands (not for ":global" and ":!")
|:quote|    "		begins comment

|:_%|	    %		current file name (only where a file name is expected)
|:_#|	    #[num]	alternate file name [num] (only where a file name is
			   expected)
	Note: The next four are typed literally; these are not special keys!
|:<cword>|  <cword>	word under the cursor (only where a file name is
			   expected)
|:<cWORD>|  <cWORD>	WORD under the cursor (only where a file name is
			   expected) (see |WORD|)
|:<cfile>|  <cfile>	file name under the cursor (only where a file name is
			   expected)
|:<afile>|  <afile>	file name for autocommand (only where a file name is
			   expected)
|:<sfile>|  <sfile>	file name of a ":source"d file, within that file (only
			   where a file name is expected)

		After "%", "#", "<cfile>", "<sfile>" or "<afile>"
		|::p|	    :p		full path
		|::h|	    :h		head (file name removed)
		|::t|	    :t		tail (file name only)
		|::r|	    :r		root (extension removed)
		|::e|	    :e		extension
		|::s|	    :s/{pat}/{repl}/	substitute {pat} with {repl}
------------------------------------------------------------------------------
*X_ed*		Editing a file

|:edit_f|  :e[dit] {file}	Edit {file}, unless changes have been made.
|:edit!_f| :e[dit]! {file}	Edit {file} always.  Discard any changes.
|:edit|	   :e[dit]		Reload the current file, unless changes have
				   been made.
|:edit!|   :e[dit]!		Reload the current file always.  Discard any
				   changes.
|:find|    :fin[d][!] {file}	Find {file} in 'path' and edit it.
|CTRL-^|   N   CTRL-^		Edit alternate file N (equivalent to ":e #N").
|gf|	       gf  or ]f	Edit the file whose name is under the cursor
|:pwd|	   :pwd			Print the current directory name.
|:cd|	   :cd [path]		Change the current directory to [path].
|:cd-|	   :cd -		Back to previous current directory.
|:file|	   :f[ile]		Print the current file name and the cursor
				   position.
|:file|	   :f[ile] {name}	Set the current file name to {name}.
|:files|   :files		Show alternate file names.
------------------------------------------------------------------------------
*X_fl*		Using the argument list			|argument-list|

|:args|	   :ar[gs]		Print the argument list, with the current file
				   in "[]".
|:all|	   :all  or :sall	Open a window for every file in the arg list.
|:wn|	   :wn[ext][!]		Write file and edit next file.
|:wn|	   :wn[ext][!] {file}	Write to {file} and edit next file, unless
				   {file} exists.  With !, overwrite existing
				   file.
|:wN|	   :wN[ext][!] [file]	Write file and edit previous file.

	     in current window    in new window	~
|:argument|  :argu[ment] N	  :sar[gument] N	Edit file N
|:next|	     :n[ext]		  :sn[ext]		Edit next file
|:next_f|    :n[ext] {arglist}	  :sn[ext] {arglist}	define new arg list
							   and edit first file
|:Next|	     :N[ext]		  :sN[ext]		Edit previous file
|:rewind|    :rew[ind][!]	  :srew[ind]		Edit first file
|:last|	     :last		  :slast		Edit last file
------------------------------------------------------------------------------
*X_wq*		Writing and quitting

|:w|	  :[range]w[rite][!]		Write to the current file.
|:w_f|	  :[range]w[rite] {file}	Write to {file}, unless it already
					   exists.
|:w_f|	  :[range]w[rite]! {file}	Write to {file}.  Overwrite an existing
					   file.
|:w_a|	  :[range]w[rite][!] >>		Append to the current file.
|:w_a|	  :[range]w[rite][!] >> {file}	Append to {file}.
|:w_c|	  :[range]w[rite] !{cmd}	Execute {cmd} with [range] lines as
					   standard input.
|:up|	  :[range]up[date][!]		write to current file if modified
|:wall|	  :wall[!]			write all changed buffers

|:q|	  :q[uit]		Quit current buffer, unless changes have been
				   made.  Exit Vim when there are no other
				   non-help buffers
|:q|	  :q[uit]!		Quit current buffer always, discard any
				   changes.  Exit Vim when there are no other
				   non-help buffers
|:qa|	  :qall			Exit Vim, unless changes have been made.
|:qa|	  :qall!		Exit Vim always, discard any changes.
|:cq|	  :cq			Quit without writing and return error code.

|:wq|	  :wq[!]		Write the current file and exit.
|:wq|	  :wq[!] {file}		Write to {file} and exit.
|:xit|	  :x[it][!] [file]	Like ":wq" but write only when changes have
				   been made
|ZZ|	     ZZ			Same as ":x".
|ZQ|	     ZQ			Same as ":q!".
|:xall|	  :xall[!]  or :wqall[!]
				Write all changed buffers and exit

|:stop|	  :st[op][!]		Suspend VIM or start new shell. If 'aw' option
				   is set and [!] not given write the buffer.
|CTRL-Z|     CTRL-Z		Same as ":stop"
------------------------------------------------------------------------------
*X_st*		Starting VIM

|-vim|	   vim [options]		start editing with an empty buffer
|-file|	   vim [options] {file} ..	start editing one or more files
|--|	   vim [options] -		read file from stdin
|-tag|	   vim [options] -t {tag}	edit the file associated with {tag}
|-qf|	   vim [options] -q [fname]	start editing in QuickFix mode,
					   display the first error

	Vim arguments:

|-gui|	-g		    start GUI (also allows other options)

|-+|	+[num]		    put the cursor at line [num] (default: last line)
|-+c|	+{command}	    execute {command} after loading the file
|-+/|	+/{pat} {file} ..   put the cursor at the first occurrence of {pat}
|-v|	-v		    Vi mode, start ex in Normal mode
|-e|	-e		    Ex mode, start vim in Ex mode
|-R|	-R		    Read-only mode, implies -n
|-m|	-m		    modifications not allowed (resets 'write' option)
|-b|	-b		    binary mode
|-l|	-l		    lisp mode
|-F|	-F		    Farsi mode ('fkmap' and 'rightleft' are set)
|-H|	-H		    Hebrew mode ('hkmap' and 'rightleft' are set)
|-V|	-V		    Verbose, give informative messages
|-C|	-C		    Compatible, set the 'compatible' option
|-N|	-N		    Nocompatible, reset the 'compatible' option
|-r|	-r		    give list of swap files
|-r|	-r {file} ..	    recover aborted edit session
|-n|	-n		    do not create a swap file
|-o|	-o [num]	    open [num] windows (default: one for each file)
|-f|	-f		    GUI: foreground process, don't fork
			    Amiga: do not restart VIM to open a window (for
				e.g., mail)
|-s|	-s {scriptin}	    first read commands from the file {scriptin}
|-w|	-w {scriptout}	    write typed chars to file {scriptout} (append)
|-W|	-W {scriptout}	    write typed chars to file {scriptout} (overwrite)
|-T|	-T {terminal}	    set terminal name
|-d|	-d {device}	    Amiga: open {device} to be used as a console
|-u|	-u {vimrc}	    read inits from {vimrc} instead of other inits
|-U|	-U {gvimrc}	    idem, for when starting the GUI
|-i|	-i {viminfo}	    read info from {viminfo} instead of other files
|---|	--		    end of options, other arguments are file names
|--help|    --help	    show list of arguments and exit
|--version| --version	    show version info and exit
|--|	-		    Read file from stdin.
------------------------------------------------------------------------------
*X_ac*		Automatic Commands

|viminfo-file|	Read registers, marks, history at startup, save when exiting.

|:rviminfo|	:rv[iminfo] [file]	Read info from viminfo file [file]
|:rviminfo|	:rv[iminfo]! [file]	idem, overwrite existing info
|:wviminfo|	:wv[iminfo] [file]	Add info to viminfo file [file]
|:wviminfo|	:wv[iminfo]! [file]	Write info to viminfo file [file]

|modeline|	Automatic option setting when editing a file

|modeline|	vim:{set-arg}: ..	In the first and last lines of the
					file (see 'ml' option), {set-arg} is
					given as an argument to ":set"

|autocommand|	Automatic execution of commands on certain events.

|:autocmd|	:au			List all autocommands
|:autocmd|	:au {event}		List all autocommands for {event}
|:autocmd|	:au {event} {pat}	List all autocommands for {event} with
					{pat}
|:autocmd|	:au {event} {pat} {cmd}	Enter new autocommands for {event}
					with {pat}
|:autocmd|	:au!			Remove all autocommands
|:autocmd|	:au! {event}		Remove all autocommands for {event}
|:autocmd|	:au! * {pat}		Remove all autocommands for {pat}
|:autocmd|	:au! {event} {pat}	Remove all autocommands for {event}
					with {pat}
|:autocmd|	:au! {event} {pat} {cmd}  Remove all autocommands for {event}
					with {pat} and enter new one
------------------------------------------------------------------------------
*X_wi*		Multi-window functions

|CTRL-W_s|	CTRL-W s  or  :split	Split window into two parts
|:split_f|	:split {file}		Split window and edit {file} in one of
					   them
|:sfind|	:sf[ind] {file}		Split window, find {file} in 'path'
					   and edit it.
|CTRL-W_]|	CTRL-W ]		Split window and jump to tag under
					   cursor
|CTRL-W_f|	CTRL-W f		Split window and edit file name under
					   the cursor
|CTRL-W_CTRL-^| CTRL-W CTRL-^		Split window and edit alternate file
|CTRL-W_n|	CTRL-W n  or  :new	Create new empty window
|CTRL-W_q|	CTRL-W q  or  :q[uit]	Quit editing and close window
|CTRL-W_c|	CTRL-W c  or  :cl[ose]	Make buffer hidden and close window
|CTRL-W_o|	CTRL-W o  or  :on[ly]	Make current window only one on the
					   screen

|CTRL-W_j|	CTRL-W j		Move cursor to window below
|CTRL-W_k|	CTRL-W k		Move cursor to window above
|CTRL-W_CTRL-W|	CTRL-W CTRL-W		Move cursor to window below (wrap)
|CTRL-W_W|	CTRL-W W		Move cursor to window above (wrap)
|CTRL-W_t|	CTRL-W t		Move cursor to top window
|CTRL-W_b|	CTRL-W b		Move cursor to bottom window
|CTRL-W_p|	CTRL-W p		Move cursor to previous active window

|CTRL-W_r|	CTRL-W r		Rotate windows downwards
|CTRL-W_R|	CTRL-W R		Rotate windows upwards
|CTRL-W_x|	CTRL-W x		Exchange current window with next one

|CTRL-W_=|	CTRL-W =		Make all windows equal height
|CTRL-W_-|	CTRL-W -		Decrease current window height
|CTRL-W_+|	CTRL-W +		Increase current window height
|CTRL-W__|	CTRL-W _		Set current window height (default:
					   very high)
------------------------------------------------------------------------------
*X_bu*		Buffer list functions

|:buffers|	:buffers  or  :files	list all known buffer and file names

|:ball|		:ball	  or  :sball	edit all args/buffers
|:unhide|	:unhide   or  :sunhide	edit all loaded buffers

|:badd|		:badd {fname}		add file name {fname} to the list
|:bunload|	:bunload[!] [N]		unload buffer [N] from memory
|:bdelete|	:bdelete[!] [N]		unload buffer [N] and delete it from
					   the buffer list

	      in current window   in new window	~
|:buffer|     :[N]buffer [N]	  :[N]sbuffer [N]     to arg/buf N
|:bnext|      :[N]bnext [N]	  :[N]sbnext [N]      to Nth next arg/buf
|:bNext|      :[N]bNext [N]	  :[N]sbNext [N]      to Nth previous arg/buf
|:bprevious|  :[N]bprevious [N]   :[N]sbprevious [N]  to Nth previous arg/buf
|:brewind|    :brewind		  :sbrewind	      to first arg/buf
|:blast|      :blast		  :sblast	      to last arg/buf
|:bmodified|  :[N]bmod [N]	  :[N]sbmod [N]	      to Nth modified buf
------------------------------------------------------------------------------
*X_sy*		Syntax Highlighting

|:syn-on|	:syntax on		start using syntax highlighting
|:syn-off|	:syntax off		stop using syntax highlighting

|:syn-keyword|	:syntax keyword {group-name} {keyword} ..
					add a syntax keyword item
|:syn-match|	:syntax match {group-name} {pattern} ...
					add syntax match item
|:syn-region|	:syntax region {group-name} {pattern} ...
					add syntax region item
|:syn-sync|	:syntax sync [ccomment | lines {N} | ...]
					tell syntax how to sync
|:syntax|	:syntax [list]		list current syntax items
|:syn-clear|	:syntax clear		clear all syntax info

|:highlight|	:highlight clear	clear all highlight info
|:highlight|	:highlight {group-name} {key}={arg} ..
					set highlighting for {group-name}

|:filetype|	:filetype on		switch on file type detection, without
					syntax highlighting
------------------------------------------------------------------------------
*X_gu*		GUI commands

|:gui|		:gui			UNIX: start the GUI
|:gui|		:gui {fname} ..		idem, and edit {fname} ..

|:menu|		:menu			list all menus
|:menu|		:menu {mpath}		list menus starting with {mpath}
|:menu|		:menu {mpath} {rhs}	add menu {mpath}, giving {lhs}
|:menu|		:menu {pri} {mpath} {rhs}
					idem, with priorities {pri}
|:menu|		:menu ToolBar.{name} {rhs}
					add toolbar item, giving {lhs}
|:tmenu|	:tmenu {mpath} {text}	add tooltip to menu {mpath}
|:unmenu|	:unmenu {mpath}		remove menu {mpath}

------------------------------------------------------------------------------
*bars*		Bars example

Now that you've jumped here with CTRL-] or a double mouse click, you can use
CTRL-T, CTRL-O, g<RightMouse>, or <C-RightMouse> to go back to where you were.
------------------------------------------------------------------------------
 vim:ts=8:sw=8:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":
