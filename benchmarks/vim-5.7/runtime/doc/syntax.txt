*syntax.txt*    For Vim version 5.7.  Last change: 2000 Jun 22


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Syntax highlighting		*syntax* *syntax-highlighting* *coloring*

Syntax highlighting enables the possibility to show parts of the text in
another font or color.  Those parts can be specific keywords or text
matching a pattern.  Vim doesn't parse the whole file (to keep it fast), so
the highlighting has its limitations.  Lexical highlighting might be a
better name, but everybody calls it syntax highlighting, so we'll stick with
that.

Vim supports syntax highlighting on all terminals.  But since most ordinary
terminals have very limited highlighting possibilities, it works best in the
GUI version, gvim.

1.  Quick start			|:syn-qstart|
2.  Syntax files		|:syn-files|
3.  Syntax loading procedure	|syntax-loading|
4.  Syntax file remarks		|:syn-file-remarks|
5.  Defining a syntax		|:syn-define|
6.  :syntax arguments		|:syn-arguments|
7.  Syntax patterns		|:syn-pattern|
8.  Syntax clusters		|:syn-cluster|
9.  Including syntax files	|:syn-include|
10. Synchronizing		|:syn-sync|
11. Listing syntax items	|:syntax|
12. Highlight command		|:highlight|
13. Linking groups		|:highlight-link|
14. Cleaning up			|:syn-clear|
15. Highlighting tags		|tag-highlight|
16. Color xterms		|xterm-color|

{Vi does not have any of these commands}

The syntax highlighting is not available when the |+syntax| feature has been
disabled at compile time.

==============================================================================
1. Quick start						*:syn-qstart*

							*:syn-on*
For a large number of common languages syntax files have been included.  To
start using them, type this command:
>  :syntax on

This will enable automatic syntax highlighting.  The type of highlighting will
be selected using the file name extension, and sometimes using the first line
of the file.

Include this command in your .vimrc if you always want syntax highlighting, or
put it in your .gvimrc if you only want it in the GUI.  If you don't want it
for B&W terminals, but you do want it for color terminals, put this in your
.vimrc:
>  if &t_Co > 1
>    syntax on
>  endif

What this command actually does, is executing the command
>  source $VIMRUNTIME/syntax/syntax.vim
If the VIM environment variable is not set, Vim will try to find
the path in another way (see |$VIMRUNTIME|).  Normally this will work just
fine.  If it doesn't, try setting the VIM environment variable to the
directory where the Vim stuff is located.  For example, if your syntax files
are in the "/usr/vim/vim50/syntax" directory, set $VIMRUNTIME to
"/usr/vim/vim50".  You must do this in the shell, before starting Vim.

							*:syn-default-override*
You can override the default highlight settings, by issuing ":highlight"
commands after sourcing "syntax.vim".  For example:
>  syntax on
>  highlight Constant gui=NONE guibg=grey95

This will change the GUI highlighting for the "Constant" group.  See
|:highlight| about how to specify highlighting attributes.

If you are running in the GUI, you can get white text on a black background
with:
>  highlight Normal guibg=Black guifg=White

If you have a black background, use these commands to get better colors (see
'background'):
>  set background=dark
>  syntax on

NOTE: The syntax files on MS-DOS and Windows have lines that end in <CR><NL>.
The files for Unix end in <NL>.  This means you should use the right type of
file for your system.  Although on MS-DOS and Windows the right format is
automatically selected if the 'fileformats' option is not empty.

NOTE: When using reverse video ("gvim -fg white -bg black"), the default value
of 'background' will not be set until the GUI window is opened, which is after
reading the .gvimrc.  This will cause the wrong default highlighting to be
used.  To set the default value of 'background' before switching on
highlighting, include the ":gui" command in the .gvimrc:

>  :gui		" open window and set default for 'background'
>  :syntax on	" start highlighting, use 'background' to set colors

NOTE: Using ":gui" in the .gvimrc means that "gvim -f" won't start in the
foreground!  Use ":gui -f" then.


To switch off the syntax highlighting:			*:syn-off*
>  :syntax off
This will completely disable syntax highlighting and remove it immediately for
all buffers.

You can toggle the syntax on/off with this command
>  :if exists("syntax_on") | syntax off | else | syntax on | endif

To put this into a mapping, you can use:
>  map <F7> :if exists("syntax_on") <Bar> syntax off <Bar> else <Bar> syntax on <Bar> endif <CR>
[using the |<>| notation, type this literally]


To make syntax highlighting work only in selected buffers:	*:syn-manual*
>   :syntax manual
This will enable the syntax highlighting, but not switch it on automatically
when starting to edit a buffer.  This is because the FileType autocommands are
not used to select a syntax.

Now you can still switch on syntax highlighting for a buffer by setting the
'syntax' option.  For example, to switch on fortran highlighting:
>   :set syntax=fortran
This can also be done with a |modeline|, so that files that include a modeline
that sets the 'syntax' option will be highlighted.  For example, this line can
be used in a Makefile:
>   # vim: syntax=make

							*syntax-printing*
If you want to print your colored text, you will have to convert it to HTML
first, and then print it from a browser.  See |2html.vim|.


Details
The ":syntax" commands are implemented by sourcing a file.  To see exactly how
this works, look in the file:
    command		file ~
    :syntax on		$VIMRUNTIME/syntax/syntax.vim
    :syntax manual	$VIMRUNTIME/syntax/manual.vim
    :syntax off		$VIMRUNTIME/syntax/nosyntax.vim
Also see |syntax-loading|.

==============================================================================
2. Syntax files						*:syn-files*

The syntax and highlighting commands for one language are normally stored in
a syntax file.  The name convention is: "{name}.vim".  Where {name} is the
name of the language, or an abbreviation (to fit the name in 8.3 characters,
which is always done, in case the file will be used on a DOS filesystem).
Examples:
	c.vim		perl.vim	java.vim	html.vim
	cpp.vim		sh.vim		csh.vim

The syntax file can contain any Ex commands, just like a vimrc file.  But
the idea is that only commands for a specific language are included.  When a
language is a superset of another language, it may include the other one,
for example, the cpp.vim file could include the c.vim file:
>  :so $VIMRUNTIME/syntax/c.vim

The .vim files are normally loaded with an autocommand.  For example:
>  :au Syntax c	    source $VIMRUNTIME/syntax/c.vim
>  :au Syntax cpp   source $VIMRUNTIME/syntax/cpp.vim
These commands are normally in the file $VIMRUNTIME/syntax/synload.vim.


MAKING YOUR OWN SYNTAX FILES				*mysyntaxfile*

When you create your own syntax files, and you want to have these
automatically used with ":syntax on", do this:

1. Create a file that contains the autocommands to load your syntax files when
   the right file type is detected.  To prevent loading two syntax files (when
   the file type is used twice), first delete other autocommands for the same
   file type.  You can also include ":highlight" commands in this file, which
   override the normal highlighting (because the file is sourced after setting
   the normal highlighting).  Example:
>    au! Syntax dosbatch    so ~/vim/batch.vim
>    au! Syntax mine	    so ~/vim/mine.vim
>    highlight Comment gui=bold
   Let's assume you write this file in "~/vim/mysyntax.vim".

   Note that when you introduce a new file type, this must first be detected.
   See |myfiletypefile|.

							*mysyntaxfile-file*
2. In your .vimrc, set the "mysyntaxfile" variable to the file you just
   created.  For example:
>    let mysyntaxfile = "~/vim/mysyntax.vim"
   Put this before ":syntax on"!

If you want to use a new file type, see |new-filetype|.

Note that "mysyntaxfile" is sourced AFTER defining the default autocommands
for the supplied syntax files, so that you can override these autocommands
with your own.

If you are setting up a system with many users, and you don't want each user
to add the same syntax file, consider creating a vimrc file that is used for
all everybody.  See |system-vimrc|.


ADDING TO AN EXISTING SYNTAX FILE			*mysyntaxfile-add*

If you are mostly satisfied with an existing syntax file, but would like to
add a few items or change the highlighting, follow these steps:

1. In your vimrc file, set "mysyntaxfile":
>	let mysyntaxfile = "/home/someone/vim/mysyntax.vim"

2. In the "mysyntax.vim" file, put an autocommand to source your extra syntax
   items:
>	" FooBar language
>	:autocmd Syntax foobar		source /home/someone/vim/foobar.vim
   Check: if you do ":autocmd Syntax foobar" you wil see both the original
   syntax file and the one you just added:
>	Syntax
>	   foobar	so $VIMRUNTIME/syntax/foobar.vim
>	   foobar	source /home/someone/vim/foobar.vim

3. In the additional language file, put the items you want to add:
>	syntax keyword foobarType	Short Long
>	hi link foobarType	Type
>	hi foobarComment guifg=Green


REPLACING AN EXISTING SYNTAX FILE			*mysyntaxfile-replace*

If you don't like a distributed syntax file, or you have downloaded a new
version, follow the same steps as above, but at the second item add a "!" to
the autocmd:
>	" FooBar language
>	:autocmd! Syntax foobar		source /home/someone/vim/foobar.vim
Check: If you do ":autocmd Syntax foobar" you will only see the syntax file
you just added:
>	Syntax
>	   foobar	source /home/someone/vim/foobar.vim


NAMING CONVENTIONS
							*group-name*
To be able to allow each user to pick his favorite set of colors, there need
to be preferred names for highlight groups that are common for many languages.
These are the ones that are suggested to be used:

	*Comment	any comment

	*Constant	any constant
	 String		a string constant: "this is a string"
	 Character	a character constant: 'c', '\n'
	 Number		a number constant: 234, 0xff
	 Boolean	a boolean constant: TRUE, false
	 Float		a floating point constant: 2.3e10

	*Identifier	any variable name
	 Function	function name (also: methods for classes)

	*Statement	any statement
	 Conditional	if, then, else, endif, switch, etc.
	 Repeat		for, do, while, etc.
	 Label		case, default, etc.
	 Operator	"sizeof", "+", "*", etc.
	 Keyword	any other keyword
	 Exception	try, catch, throw

	*PreProc	generic Preprocessor
	 Include	preprocessor #include
	 Define		preprocessor #define
	 Macro		same as Define
	 PreCondit	preprocessor #if, #else, #endif, etc.

	*Type		int, long, char, etc.
	 StorageClass	static, register, volatile, etc.
	 Structure	struct, union, enum, etc.
	 Typedef	A typedef

	*Special	any special symbol
	 SpecialChar	special character in a constant
	 Tag		you can use CTRL-] on this
	 Delimiter	character that needs attention
	 SpecialComment	special things inside a comment
	 Debug		debugging statements

	*Ignore		left blank, hidden

	*Error		any erroneous construct

	*Todo		anything that needs extra attention; mostly the
			keywords TODO FIXME and XXX

The ones marked with * are the preferred groups, the other are minor groups.
For the preferred groups, the "syntax.vim" file contains default highlighting.
The minor groups are linked to the preferred groups, so they get the same
highlighting.  You can override these defaults by giving ":highlight" commands
after sourcing the "syntax.vim" file.

Note that highlight group names are not case sensitive.  "String" and "string"
can be used for the same group.

The following names are reserved and cannot be used as a group name:
	NONE   ALL   ALLBUT   contains   contained

==============================================================================
3. Syntax loading procedure				*syntax-loading*

This explains the details that happen when the command ":syntax on" is issued.
When Vim initializes itself, it finds out where the runtime files are located.
This is used here as the variable |$VIMRUNTIME|.

What ":syntax on" does:

    Source $VIMRUNTIME/syntax/syntax.vim
    |
    +-	Clear out any old syntax.
    |
    +-	Source $VIMRUNTIME/syntax/synload.vim
    |	|
    |	+-  Set up standard highlighting groups
    |	|
    |	+-  Set up syntax autocmds to load the appropriate syntax file when
    |	|   the 'syntax' option is set. *synload-1*
    |	|
    |	+-  Source the user's optional file, from the |mysyntaxfile| variable.
    |	    This is where you can add your own syntax autocommands for loading
    |	    your syntax file when the 'syntax' option is set.  You can also
    |	    modify the standard highlighting here. *synload-2*
    |
    +-	Source $VIMRUNTIME/filetype.vim
    |	|
    |	+-  Install autocmds based on suffix to set the 'filetype' option
    |	|   This is where the connection between file name and file type is
    |	|   made for known file types. *synload-3*
    |	|
    |	+-  Source the user's optional file, from the |myfiletypefile|
    |	|   variable.  This is where you can add your own connections between
    |	|   file name and file type.  Or overrule existing ones. *synload-4*
    |	|
    |	+-  Install one autocommand which loads $VIMRUNTIME/scripts.vim when
    |	|   no file type was detected yet. *synload-5*
    |	|
    |	+-  Source $VIMRUNTIME/menu.vim, to setup the Syntax menu. |menu.vim|
    |
    +-	Install a FileType autocommand to set the 'syntax' option when a file
    |	type has been detected. *synload-6*
    |
    +-	Execute syntax autocommands to start syntax highlighting for each
	already loaded buffer.


When a file is loaded, its syntax file is found in this way:

    Loading the file triggers the BufReadPost autocommands.
    |
    +-	If there is a match with one of the autocommands from |synload-3|
    |	(known file types) or |synload-4| (user's file types), the 'filetype'
    |	option is set to the file type.
    |
    +-	The autocommand at |synload-5| is triggered.  If the file type was not
    |	found yet, then $VIMRUNTIME/scripts.vim is sourced.
    |	|
    |	+-  Source the user's optional |myscriptsfile|.  This typically makes
    |	|   checks using "getline(1) =~ pattern" to find out which file type
    |	|   the file is, and sets 'filetype'.
    |	|
    |	+-  If the file type is still unknown, check the contents of the file,
    |	    again with checks like "getline(1) =~ pattern" as to whether the
    |	    file type can be recognized, and set 'filetype'.
    |
    +-	When the file type was determined and 'filetype' was set, this
    |	triggers the FileType autocommand |synload-6| above.  It sets
    |	'syntax' to the determined file type.
    |
    +-	When the 'syntax' option was set above, this triggers an autocommand
    |	from |synload-1| or |synload-2|.  This will source the syntax file in
    |	the $VIMRUNTIME/syntax directory or the user's syntax file.
    |
    +-	Any other user installed FileType or Syntax autocommands are
	triggered.  This can be used to change the highlighting for a specific
	syntax.

==============================================================================
4. Syntax file remarks					*:syn-file-remarks*

						*b:current_syntax-variable*
The name of the syntax that has been loaded is stored in the
"b:current_syntax" variable.  You can use this if you want to load other
settings, depending on which syntax is active.  Example:
>  :au BufReadPost * if b:current_syntax == "csh"
>  :au BufReadPost *   do-some-things
>  :au BufReadPost * endif


2HTML						*2html.vim* *convert-to-HTML*

This is not a syntax file itself, but a script that converts the current
window into HTML.  A new window is opened, in which the HTML file is built.
	Warning: This is slow!
The resulting file can be written where you want it.  You can then view it
with any HTML viewer, such as Netscape.  The colors should be exactly the same
as you see them in Vim.
If you want the lines to be numbered, set the "html_number_color" variable to
the color name of the line number.  The color name must be valid in HTML.
Example:
>   let html_number_color = "#804000"
To stop this, remove the variable:
>   unlet html_number_color
Remarks:
- This only works in a version with GUI support.  If the GUI not actually
  running (possible for X11) it still works, but not that good (the color
  names may be wrong).
- In older browsers the background colors will not be shown.
- From Netscape you can also print the file (in color)!
- When 'tabstop' is not 8, the amount of white space will be wrong.

Here is an example how to run the script over all .c and .h files from a
Unix shell:
>  $ for f in *.[ch]; do gvim -f +"syn on" +"so \$VIMRUNTIME/syntax/2html.vim" +"wq" +"q" $f; done


Assembly			*asm.vim* *asmh8300.vim* *nasm.vim* *masm.vim*

There are many types of assembly languages that all use the same file name
extensions.  Therefore you will have to select the type yourself, or add a
line in the assembly file that Vim will recognize.  Currently these syntax
files are included:
	asm		GNU assembly (the default)
	asmh8300	Hitachi H-8300 version of GNU assembly
	masm		Microsoft assembly (probably works for any 80x86)
	nasm		Netwide assembly

The most flexible is to add a line in your assembly file containing:
>	asmsyntax=nasm
Replace "nasm" with the name of the real assembly syntax.  This line must be
one of the first five lines in the file.

The syntax type can always be overruled for a specific buffer by setting the
b:asmsyntax variable:
>	let b:asmsyntax=nasm

If b:asmsyntax is not set, either automatically or by hand, then the value of
the global variable asmsyntax is used.  This can be seen as a default assembly
language:
>	let asmsyntax=nasm

As a last resort, if nothing is defined, the "asm" syntax is used.


Netwide assembler (nasm.vim) optional highlighting ~

To enable a feature:
>	let   {variable}=1|set syntax=nasm
To disable a feature:
>	unlet {variable}  |set syntax=nasm

Variable		Highlight ~
nasm_loose_syntax	unofficial parser allowed syntax not as Error
			  (parser dependend; not recommended)
nasm_ctx_outside_macro	contexts outside macro not as Error
nasm_no_warn		potentially risky syntax not as ToDo


							*basic.vim* *vb.vim*
Both Visual Basic and "normal" basic use the extension ".bas".  To detect
which one should be used, Vim checks for the string "VB_Name" in the first
five lines of the file.  If it is not found, filetype will be "basic",
otherwise "vb".  Files with the ".frm" extension will always be seen as Visual
Basic.


C							*c.vim*

A few things in C highlighting are optional.  To enable them assign any value
to the respective value.  Example:
>  let c_comment_strings=1
To disable them use ":unlet".  Example:
>  unlet c_comment_strings

variable		Highlight ~
c_comment_strings	strings and numbers inside a comment
c_space_errors		trailing white space and spaces before a <Tab>
c_no_trail_space_error	 ... but no trailing spaces
c_no_tab_space_error	 ... but no spaces before a <Tab>
c_no_ansi		don't do standard ANSI types and constants
c_ansi_typedefs		 ... but do standard ANSI types
c_ansi_constants	 ... but do standard ANSI constants
c_no_utf		don't highlight \u and \U in strings
c_syntax_for_h		use C syntax for *.h files, instead of C++
c_no_if0		don't highlight "#if 0" blocks as comments
c_no_cformat		don't highlight %-formats in strings

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "c_minlines" internal variable
to a larger number:
>  let c_minlines = 100
This will make the syntax synchronization start 100 lines before the first
displayed line.  The default value is 50 (15 when c_no_if0 is set).  The
disadvantage of using a larger number is that redrawing can become slow.

When using the "#if 0" / "#endif" comment highlighting, notice that this only
works when the "#if 0" is within "c_minlines" from the top of the window.  If
you have a long "#if 0" construct it will not be highlighted correctly.

To match extra items in comments the cCommentGroup cluster can be used.
Example:
>   au Syntax c call MyCadd()
>   function MyCadd()
>     syn keyword cMyItem contained Ni
>     syn cluster cCommentGroup add=cMyItem
>     hi link cMyItem Title
>   endfun

ANSI constants will be highlighted with the "cConstant" group.  This includes
"NULL", "SIG_IGN" and others.  But not "TRUE", for example, because this is
not in the ANSI standard.  If you find this confusing, remove the cConstant
highlighting:
>   :hi link cConstant NONE


COBOL							*cobol.vim*

COBOL highlighting for legacy code has different needs than fresh development.
This is due both to differences in what is being done (maintenance versus
development) as well as other factors.  To enable legacy code highlighting,
add this line to you .vimrc:
>  let cobol_legacy_code=1
To disable it again, use this:
>  unlet cobol_legacy_code


DTD							*dtd.vim*

The DTD syntax highlighting is case sensitive by default. To disable
case-sensitive highlighting, add the following line to your startup file:

>  let dtd_ignore_case=1
>
The DTD syntax file will highlight unknown tags as errors. If
this is annoying, it can be turned off by setting:

>  let dtd_no_tag_errors=1
>
before sourcing the dtd.vim syntax file.
Parameter entity names are highlighted in the definition using the
'Type' highlighting group and 'Comment' for punctuation and '%'.
Parameter entity instances are highlighted using the 'Constant'
highlighting group and the 'Type' highlighting group for the
delimiters % and ;. This can be turned off by setting:
>
>  let dtd_no_param_entities=1

The DTD syntax file is also included by xml.vim to highlight included dtd's.
>

EIFFEL							*eiffel.vim*

While Eiffel is not case-sensitive, its style guidelines are, and the
syntax highlighting file encourages their use. This also allows to
highlight class names differently. If you want to disable case-sensitive
highlighting, add the following line to your startup file:

>  let eiffel_ignore_case=1

Case still matters for class names and TODO marks in comments.

Conversely, for even stricter checks, add one of the following lines:

>  let eiffel_strict=1
>  let eiffel_pedantic=1

Setting eiffel_strict will only catch improper capitalization for the
five predefined words "Current", "Void", "Result", "Precursor", and
"NONE", to warn against their accidental use as feature or class names.

Setting eiffel_pedantic will enforce adherence to the Eiffel style
guidelines fairly rigorously (like arbitrary mixes of upper- and
lowercase letters as well as outdated ways to capitalize keywords).

If you want to use the lower-case version of "Current", "Void",
"Result", and "Precursor", you can use

>  let eiffel_lower_case_predef=1

instead of completely turning case-sensitive highlighting off.

Support for ISE's proposed new creation syntax that is already
experimentally handled by some compilers can be enabled by:

>  let eiffel_ise=1

Finally, some vendors support hexadecimal constants. To handle them, add

>  let eiffel_hex_constants=1

to your startup file.


ERLANG							*erlang.vim*

The erlang highlighting supports Erlang (ERicsson LANGuage).
Erlang is case sensitive and default extension is ".erl".

If you want to disable keywords highlighting, put in your .vimrc:
>	let erlang_keywords=1
If you want to disable special characters highlighting, put in
your .vimrc:
>	let erlang_characters=1


FORM                                                 *form.vim*

The coloring scheme for syntax elements in the FORM file uses the default
modes Conditional, Number, Statement, Comment, PreProc, Type, and String,
following the language specifications in 'Symbolic Manipulation with FORM'' by
J.A.M. Vermaseren, CAN, Netherlands, 1991.

If you want include your own changes to the default colors, you have to
redefine the following syntax groups:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

Note that the form.vim syntax file implements FORM preprocessor commands and
directives per default in the same syntax group.

A predefined enhanced color mode for FORM is available to distinguish between
header statements and statements in the body of a FORM program. To activate
this mode define the following variable in your vimrc file

>   let form_enhanced_color=1

The enhanced mode also takes advantage of additional color features for a dark
gvim display. Here, statements are colored LightYellow instead of Yellow, and
conditionals are LightBlue for better distinction.


FORTRAN							*fortran.vim*

Five dialects of Fortran are recognized by the fortran.vim script: f95,
f90, f77, the Lahey subset elf90, and the Imagine1 subset F.

If you need only f95, f90 and f77, the chances are that the default
dialect selection scheme will work correctly for you. It is based on
file extensions as follows:
Extension	Dialect ~
.f95		f95
.f90		f90
.f,.for,.fpp	f77

If you consistently use a different file extension convention, then the
defaults can be over ruled most conveniently by setting the variable
fortran_dialect in your .vimrc with an autocommand placed prior to the
:syntax on command. For example, if all your .f90 files are written in
the elf subset, then let fortran_dialect="elf" for all .f90 files. The
permissible values of fortran_dialect are case-sensitive and must be
"f95", "f90", "f77", "elf" or "F". Invalid values of fortran_dialect are
ignored.

If the dialect is f95 or f90, the Fortran code can be in either free or
fixed source form. The syntax file attempts to determine which form your
file uses by examining the first five columns of its first five lines.
The algorithm should work in the vast majority of cases. In some rare
cases, it may incorrectly decide that the fortran code is in fixed form.
If that happens, just add a non-comment statement beginning anywhere in
the first five columns of the first five lines, save and then reload the
file.

If the dialect is elf or F, the Fortran source code is assumed to be in
free source form as required by these dialects. If the dialect is f77,
the Fortran source code is assumed to be in fixed source form as
required by the Fortran 77 standard. You may find that f77 code with
extensions, such as free source form or the MIL STD 1753 extensions, is
colored better if you declare it to be f90.

Finer control is necessary if the file extension does not uniquely
identify the dialect. For example, your older .f files may be written in
f77 but your newer ones may be F codes. Then you can over ride the file
extension rules, on a file-by-file basis, by including a comment with
the directive "fortran_dialect=F" in one of the first three lines in
your file. Only three such directives are recognized: fortran_dialect=F
in .f files, and fortran_dialect=elf and fortran_dialect=F in .f90
files. F overrides elf if both directives are present in an .f90 file.

Limitations: Parenthesis checking does not catch too few closing
parentheses. Hollerith strings are not recognized. Some keywords may be
highlighted incorrectly because Fortran90 has no reserved words.


FVWM CONFIGURATION FILES				*fvwm.vim*

In order for Vim to recognize Fvwm configuration files that do not match
the patterns *fvwmrc* or *fvwm2rc*, you must put additional patterns
appropriate to your system in your myfiletypes.vim file.  For these
patterns, you must set the variable "b:fvwm_version" to the major version
number of Fvwm, and the 'filetype' option to fvwm.

For example, to make Vim identify all files in /etc/X11/fvwm2/
as Fvwm2 configuration files, add the following:

>  au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |
>                                         \ set filetype=fvwm

If you'd like Vim to highlight all valid color names, tell it where to
find the color database (rgb.txt) on your system.  Do this by setting
"rgb_file" to its location.  Assuming your color database is located
in /usr/X11/lib/X11/, you should add the line

>  let rgb_file = "/usr/X11/lib/X11/rgb.txt"

to your .vimrc file.


HTML							*html.vim*

The coloring scheme for tags in the HTML file works as follows.

The  <> of opening tags are colored differently than the </> of a closing tag.
This is on purpose! For opening tags the 'Function' color is used, while for
closing tags the 'Type' color is used (See syntax.vim to check how those are
defined for you)

Known tag names are colored the same way as statements in C.  Unknown tag
names are colored with the same color as the <> or </> respectively which
makes it easy to spot errors

Note that the same is true for argument (or attribute) names. Known attribute
names are colored differently than unknown ones.

Some HTML tags are used to change the rendering of text. The following tags
are recognized by the html.vim syntax coloring file and change the way normal
text is shown: <B> <I> <U> <EM> <STRONG> (<EM> is used as an alias for <I>,
while <STRONG> as an alias for <B>), <H1> - <H6>, <HEAD>, <TITLE> and <A>, but
only if used as a link that is, it must include a href as in
<A href="somfile.html">).

If you want to change how such text is rendered, you must redefine the
following syntax groups:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlLink for links
    - htmlTitle for titles
    - htmlH1 - htmlH6 for headings

To make this redefinition work you must redefine them all with the exception
of the last two (htmlTitle and htmlH[1-6], which are optional) and define the
following variable in your vimrc (this is due to the order in which the files
are read during initialization)
>   let html_my_rendering=1

If you'd like to see an example download mysyntax.vim at
http://www.fleiner.com/vim/mysyntax.vim

You can also disable this rendering by adding the following line to your
vimrc file:
>   let html_no_rendering=1

HTML comments are rather special (see an HTML reference document for the
details), and the syntax coloring scheme will highlight all errors.
However, if you prefer to use the wrong style (starts with <!-- and
ends with -->) you can define
>   let html_wrong_comments=1

JavaScript and Visual Basic embedded inside HTML documents are highlighted as
'Special' with statements, comments, strings and so on colored as in standard
programming languages. Note that only JavaScript and Visual Basic are currently
supported, no other scripting language has been added yet.

Embedded and inlined cascading style sheets (CSS) are highlighted too.

There are several html preprocessor languages out there. html.vim has been
written such that it should be trivial to include it. To do so add the
following two lines to the syntax coloring file for that language
(the example comes from the asp.vim file):

    source <sfile>:p:h/html.vim
    syn cluster htmlPreproc add=asp

Now you just need to make sure that you add all regions that contain
the preprocessor language to the cluster htmlPreproc.


JAVA							*java.vim*

The java.vim syntax highlighting file offers several options:

In Java 1.0.2 it was never possible to have braces inside parens, so this was
flagged as an error.  Since Java 1.1 this is possible (with anonymous
classes), and therefore is no longer marked as an error. If you prefer the old
way, put the following line into your vim startup file:
>  let java_mark_braces_in_parens_as_errors=1

All identifiers in java.lang.* are always visible in all classes.  To
highlight them use:
>  let java_highlight_java_lang_ids=1

You can also highlight identifiers of most standard java packages
if you download the script at http://www.fleiner.com/vim/syntax/javaid.vim
If you prefer to only highlight identifiers of a certain package, say
java.io use the following:
>  let java_highligh_java_io=1
Check the javaid.vim file for a list of all the packages that are supported.

Function names are not highlighted, as the way to find functions depends on
how you write java code.  The syntax file knows two possible ways to highlight
functions:

If you write function declarations that are always indented by either
a tab, 8 spaces or 2 spaces you may want to set
>  let java_highlight_functions="indent"
However, if you follow the java guidlines about how functions and classes are
supposed to be named (with respect to upper and lower cases), use
>  let java_highlight_functions="style"
If both options do not work for you, but you would still want function
declarations to be highlighted create your own definitions by changing the
definitions in java.vim or by creating your own java.vim which includes the
original one and then adds the code to highlight functions.

In java 1.1 the functions System.out.println() and System.err.println() should
only be used for debugging. Therefor it is possible to highlight debugging
statements differently. To do this you must add the following definition in
your startup file:
>  let java_highlight_debug=1
The result will be that those statements are highlighted as 'Special'
characters. If you prefer to have them highlighted differently you must define
new highlightings for the following groups.:
    Debug, DebugSpecial, DebugString, DebugBoolean, DebugType
which are used for the statement itself, special characters used in debug
strings, strings, boolean constants and types (this, super) respectively. I
have opted to chose another background for those statements.

In order to help you to write code that can be easely ported between
java and C++, all C++ keywords are marked as error in a java program.
However, if you use them regularly, you may want to define the following
variable in your .vimrc file:
>  let java_allow_cpp_keywords=1

Javadoc is a program that takes special comments out of java program files and
creates HTML pages. The standard configuration will highlight this HTML code
similarly to HTML files (see |html.vim|). You can even add javascript
and CSS inside this code (see below). There are four differences however:
  1. The title (all characters up to the first '.' which is followed by
     some white space or up to the first '@') is colored differently (to change
     the color change the group CommentTitle).
  2. The text is colored as 'Comment'.
  3. HTML comments are colored as 'Special'
  4. The special javadoc tags (@see, @param, ...) are highlighted as specials
     and the argument (for @see, @param, @exception) as Function.
To turn this feature off add the following line to your startup file:
>  let java_ignore_javadoc=1

If you use the special javadoc comment highlighting described above you
can also turn on special highlighting for javascript, visual basic
scripts and embedded CSS (stylesheets). This makes only sense if you
actually have javadoc comments that include either javascript or embedded
CSS. The options to use are
>  let java_javascript=1
>  let java_css=1
>  let java_vb=1

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "java_minlines" internal variable
to a larger number:
>  let java_minlines = 50
This will make the syntax synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.


LACE							*lace.vim*

Lace (Language for Assembly of Classes in Eiffel) is case insensitive, but the
style guide lines are not.  If you prefer case insensitive highlighting, just
define the vim variable 'lace_case_insensitive' in your startup file:
>  let lace_case_insensitive=1


LEX							*lex.vim*

Lex uses brute-force synchronizing as the "^%%$" section delimiter
gives no clue as to what section follows.  Consequently, the value for
>syn sync minlines=300
may be changed by the user if s/he is experiencing synchronization
difficulties (such as may happen with large lex files).


LITE							*lite.vim*

There are two options for the lite syntax highlighting.

If you like SQL syntax highligthing inside Strings, use this:

>  let lite_sql_query = 1

For syncing, minlines defaults to 100.  If you prefer another value, you can
set "lite_minlines" to the value you desire.  Example:

>  let lite_minlines = 200


MAPLE							*maple.vim*

Maple V, by Waterloo Maple Inc, supports symbolic algebra.  The language
supports many packages of functions which are selectively loaded by the user.
The standard set of packages' functions as supplied in Maple V release 4 may be
highlighted at the user's discretion.  Users may place in their .vimrc file:

>  let mvpkg_all= 1

to get all package functions highlighted, or users may select any subset by
choosing a variable/package from the table below and setting that variable to
1, also in their .vimrc file (prior to sourcing
$VIMRUNTIME/syntax/syntax.vim).

	Table of Maple V Package Function Selectors ~
>  mv_DEtools	 mv_genfunc	mv_networks	mv_process
>  mv_Galois	 mv_geometry	mv_numapprox	mv_simplex
>  mv_GaussInt	 mv_grobner	mv_numtheory	mv_stats
>  mv_LREtools	 mv_group	mv_orthopoly	mv_student
>  mv_combinat	 mv_inttrans	mv_padic	mv_sumtools
>  mv_combstruct mv_liesymm	mv_plots	mv_tensor
>  mv_difforms	 mv_linalg	mv_plottools	mv_totorder
>  mv_finance	 mv_logic	mv_powseries


MSQL							*msql.vim*

There are two options for the msql syntax highlighting.

If you like SQL syntax highligthing inside Strings, use this:

>  let msql_sql_query = 1

For syncing, minlines defaults to 100.  If you prefer another value, you can
set "msql_minlines" to the value you desire.  Example:

>  let msql_minlines = 200


NCF							*ncf.vim*

There is one option for NCF syntax highlighting.

If you want to have unrecognized (by ncf.vim) statements highlighted as
errors, use this:

>  let ncf_highlight_unknowns = 1

If you don't want to highlight these errors, leave it unset.


PERL							*perl.vim*

There are a number of possible options to the perl syntax highlighting.

If you use POD files or POD segments, you might:

> let perl_include_POD = 1

To handle package references in variable and function names differently from
the rest of the name (like 'PkgName::' in '$PkgName::VarName'):

> let perl_want_scope_in_variables = 1

If you want complex things like '@{${"foo"}}' to be parsed:

> let perl_extended_vars = 1

The coloring strings can be changed. By default strings and qq friends will be
highlighted like the first line. If you set the variable
perl_string_as_statement, it will be highlighted as in the second line.

   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N       (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^^N       (let perl_string_as_statement)

(^ = perlString, S = perlStatement, N = None at all)

The syncing has 3 options. The first two switch off some triggering of
synchronization and should only be needed in case it fails to work properly.
If while scrolling all of a sudden the whole screen changes color completely
then you should try and switch off one of those. Let me know if you can figure
out the line that causes the mistake.

One triggers on "^\s*sub\s*" and the other on "^[$@%]" more or less.

> let perl_no_sync_on_sub
> let perl_no_sync_on_global_var

Below you can set the maximum distance VIM should look for starting points for
its attempts in syntax highlighting.

> let perl_sync_dist = 100


PHP3							*php3.vim*

There are three options to the php3 syntax highlighting.

If you like SQL syntax highligthing inside Strings:

>  let php3_sql_query = 1

For highligthing the Baselib methods:

>  let php3_baselib = 1

For syncing minlines is being set default to 100.  If you
prefer another value, please make use of something like:

>  let php3_minlines = 200


PHTML							*phtml.vim*

There are two options for the phtml syntax highlighting.

If you like SQL syntax highligthing inside Strings, use this:

>  let phtml_sql_query = 1

For syncing, minlines defaults to 100.  If you prefer another value, you can
set "phtml_minlines" to the value you desire.  Example:

>  let phtml_minlines = 200


POSTSCRIPT						*postscr.vim*

There are several options when it comes to highlighting PostScript.

First which version of the PostScript language to highlight.  There are
currently three defined language versions, or levels.  Level 1 is the original
and base version, and includes all extensions prior to the release of level 2.
Level 2 is the most common version around, and includes its own set of
extensions prior to the release of level 3.  Level 3 is currently the highest
level supported.  You select which level of the PostScript language you want
highlighted by defining the postscr_level variable as follows:

>  let postscr_level=2

If this variable is not defined it defaults to 2 (level 2) since this is
the most prevalent version currently.

Note, not all PS interpreters will support all language features for a
particular language level.  In particular the %!PS-Adobe-3.0 at the start of
PS files does NOT mean the PostScript present is level 3 PostScript!

If you are working with Display PostScript, you can include highlighting of
Display PS language features by defining the postscr_display variable as
follows:

>  let postscr_display=1

If you are working with Ghostscript, you can include highlighting of
Ghostscript specific language features by defining the variable
postscr_ghostscript as follows:

>  let postscr_ghostscript=1

PostScript is a large language, with many predefined elements.  While it
useful to have all these elements highlighted, on slower machines this can
cause Vim to slow down.  In an attempt to be machine friendly font names and
character encodings are not highlighted by default.  Unless you are working
explicitly with either of these this should be ok.  If you want them to be
highlighted you should set one or both of the following variables:

>  let postscr_fonts=1
>  let postscr_encodings=1

There is a stylistic option to the highlighting of and, or, and not.  In
PostScript the function of these operators depends on the types of their
operands - if the operands are booleans then they are the logical operators,
if they are integers then they are binary operators.  As binary and logical
operators can be highlighted differently they have to be highlighted one way
or the other.  By default they are treated as logical operators.  They can be
highlighted as binary operators by defining the variable
postscr_andornot_binary as follows:

>  let postscr_andornot_binary=1


PRINTCAP + TERMCAP		*ptcap.vim* *termcap-syntax* *printcap-syntax*

This syntax file applies to the printcap and termcap databases.

In order for Vim to recognize printcap/termcap files that do not match
the patterns *printcap*, or *termcap*, you must put additional patterns
appropriate to your system in your |myfiletypefile| file.  For these
patterns, you must set the variable "b:ptcap_type" to either "print" or
"term", and then the 'filetype' option to ptcap.

For example, to make Vim identify all files in /etc/termcaps/ as termcap
files, add the following:

>  au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |
>                                       \ set filetype=ptcap

If you notice highlighting errors while scrolling backwards, which
are fixed when redrawing with CTRL-L, try setting the "ptcap_minlines"
internal variable to a larger number:

  let ptcap_minlines = 50

(The default is 20 lines.)

PYTHON							*python.vim*

There are four options to control Python syntax highlighting.

For highlighted numbers:
>  let python_highlight_numbers = 1

For highlighted builtin functions:
>  let python_highlight_builtins = 1

For highlighted standard exceptions:
>  let python_highlight_exceptions = 1

If you want all possible Python highlighting (the same as setting the
preceding three options):
>  let python_highlight_all = 1


REXX							*rexx.vim*

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "rexx_minlines" internal variable
to a larger number:
>  let rexx_minlines = 50
This will make the syntax synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.


RUBY							*ruby.vim*

There are a few options to the Ruby syntax highlighting.

By default, the "end" keyword is colorized according to the opening statement
of the block it closes. While useful, this feature can be expensive: if you
experience slow redrawing (or you are on a terminal with poor color support)
you may want to turn it off by defining the "ruby_no_expensive" variable:
>   let ruby_no_expensive = 1
In this case the same color will be used for all control keywords.

If you do want this feature enabled, but notice highlighting errors while
scrolling backwards, which are fixed when redrawing with CTRL-L, try setting
the "ruby_minlines" variable to a value larger than 50:
>   let ruby_minlines = 100
Ideally, this value should be a number of lines large enough to embrace your
largest class or module.

Finally, if you do not like to see too many color items around, you can define
"ruby_no_identifiers":
>   let ruby_no_identifiers = 1
This will prevent highlighting of special identifiers like "ConstantName",
"$global_var", "@instace_var", "| iterator |", and ":symbol".


SED							*sed.vim*

To make tabs stand out from regular blanks (accomplished by using Todo
highlighting on the tabs), define "highlight_sedtabs" by putting

>  let highlight_sedtabs = 1

in the vimrc file.  (This special highlighting only applies for tabs
inside search patterns, replacement texts, addresses or text included
by an Append/Change/Insert command.)  If you enable this option, it is
also a good idea to set the tab width to one character; by doing that,
you can easily count the number of tabs in a string.

Bugs:

  The transform command (y) is treated exactly like the substitute
  command.  This means that, as far as this syntax file is concerned,
  transform accepts the same flags as substitute, which is wrong.
  (Transform accepts no flags.)  I tolerate this bug because the
  involved commands need very complex treatment (95 patterns, one for
  each plausible pattern delimiter).


SH							*sh.vim*

This covers the "normal" Unix sh, bash and the korn shell.  If you're working
on a system where bash is called sh, you will benefit to define the vim
variable 'bash_is_sh' in your '.vimrc' file:
>  let bash_is_sh = 1
If some buffers use bash for sh, use the buffer-local variable:
>  let b:is_bash = 1
You can force using the korn shell by sett a buffer-local variable:
>  let b:is_kornshell = 1

To choose between the two ways to treat single-quotes inside a pair of
double-quotes, I have introduced a Vim variable "highlight_balanced_quotes".
By default (ie by not declaring this variable) single quotes can be used
inside double quotes, and are not highlighted.  If you prefer balanced single
quotes as I do you just make the statement in your .vimrc file:
>  let highlight_balanced_quotes = 1

Similar I have introduced another vim variable "highlight_function_name" to be
used to enable/disable highlighting of the function-name in function
declaration.  Default is not to highlight the function name.  If you want to
highlight functions names, include this in your .vimrc file:
>  let highlight_function_name = 1

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "sh_minlines" internal variable
to a larger number:
>  let sh_minlines = 200
This will make the syntax synchronization start 200 lines before the first
displayed line.  The default value is 100.  The disadvantage of using a larger
number is that redrawing can become slow.

If you don't have much to synchronize on, displaying can be very slow.  To
reduce this, the "sh_maxlines" internal variable can be set:
>  let sh_maxlines = 100
The default is to use the double of "sh_minlines".  Set it to a smaller number
to speed up displaying.  The disadvantage is that highlight errors may appear.


SPEEDUP (AspenTech plant simulator)				*spup.vim*

The Speedup syntax file has some options:

- strict_subsections : If this variable is defined, only keywords for
  sections and subsections will be highlighted as statements but not
  other keywords (like WITHIN in the OPERATION section).

- highlight_types : Definition of this variable causes stream types
  like temperature or pressure to be highlighted as Type, not as a
  plain Identifier. Included are the types that are usually found in
  the DECLARE section; if you defined own types, you have to include
  them in the syntax file.

- oneline_comments : this value ranges from 1 to 3 and determines the
  highlighting of # style comments.
  oneline_comments = 1 : allow normal Speedup code after an even
  number of #s.
  oneline_comments = 2 : show code starting with the second # as
  error. This is the default setting.
  oneline_comments = 3 : show the whole line as error if it contains
  more than one #.

Since especially OPERATION sections tend to become very large due to
PRESETting variables, syncing may be critical. If your computer is
fast enough, you can increase minlines and/or maxlines near the end of
the syntax file.


TEX							*tex.vim*

The tex highlighting supports TeX, LaTeX, and some AmsTeX.  The
highlighting supports three primary zones: normal, texZone, and texMathZone.
Although a considerable effort has been made to have these zones terminate
properly, zones delineated by $..$ and $$..$$ cannot be synchronized as
there's no difference between start and end patterns.  Consequently, a
special "TeX comment" has been provided
> %stopzone
which will forcibly terminate the highlighting of either a texZone or a
texMathZone.

If you have a slow computer, you may wish to reduce the values for
> syn sync maxlines=200
> syn sync minlines=50
(especially the latter).  If your computer is fast, you may wish to
increase them.  This primarily affects synchronizing (ie. just what group,
if any, is the text at the top of the screen supposed to be in?).


TF							*tf.vim*

There is one option for the tf syntax highlighting.

For syncing, minlines defaults to 100.  If you prefer another value, you can
set "tf_minlines" to the value you desire.  Example:

>  let tf_minlines = your choice


X Pixmaps (XPM)						*xpm.vim*

xpm.vim creates its syntax items dynamically based upon the contents of the
XPM file.  Thus if you make changes e.g. in the color specification strings,
you have to source it again e.g. with ":set syn=xpm".

To copy a pixel with one of the colors, yank a "pixel" with "yl" and insert it
somewhere else with "P".

Do you want to draw with the mouse?  Try the following:
>   function! GetPixel()
>      let c = getline(line("."))[col(".") - 1]
>      echo c
>      exe "noremap <LeftMouse> <LeftMouse>r".c
>      exe "noremap <LeftDrag>  <LeftMouse>r".c
>   endfunction
>   noremap <RightMouse> <LeftMouse>:call GetPixel()<CR>
>   set guicursor=n:hor20          " to see the color beneath the cursor
This turns the right button into a pipette and the left button into a pen.
It will work with XPM files that have one character per pixel only and you
must not click outside of the pixel strings, but feel free to improve it.

It will look much better with a font in a quadratic cell size, e.g. for X:
>   set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*

==============================================================================
5. Defining a syntax					*:syn-define*

Vim understands three types of syntax items:
1. A keyword.  It can only contain keyword characters, according to the
   'iskeyword' option.  It cannot contain other syntax items.  It will only
   be recognized when it is a complete match (there are no keyword
   characters before or after the match).  "if" would match in "if(a=b)",
   but not in "ifdef x".
2. A match.  This is a match with a single regexp pattern.  It must be within
   one line.
3. A region.  This starts at a match of the start regexp pattern and
   ends with a match with the end regexp pattern.  A skip regexp pattern can
   be used to avoid matching the end pattern.

Several syntax ITEMs can be put into one syntax GROUP.  For a syntax group
you can give highlighting attributes.  For example, you could have an item
to define a "/* .. */" comment and another one that defines a "// .." comment,
and put them both in the "Comment" group.  You can then specify that a
"Comment" will be in bold font and have a blue color.  You are free to make
one highlight group for one syntax item, or put all items into one group.
This depends on how you want to specify your highlighting attributes.  Putting
each item in its own group results in having to specify the highlighting
for a lot of groups.

Note that a syntax group and a highlight group are similar.  For a highlight
group you will have given highlight attributes.  These attributes will be used
for the syntax group with the same name.

In case more than one item matches at the same position, the one that was
defined LAST wins.  Thus you can override previously defined syntax items by
using an item that matches the same text.  But a keyword always goes before a
match or region.  And a keyword with matching case always goes before a
keyword with ignoring case.


DEFINING CASE						*:syn-case*

:sy[ntax] case [match|ignore]
	This defines if the following ":syntax" commands will work with
	matching case, when using "match", or with ignoring case, when using
	"ignore".  Note that any items before this are not affected, and all
	items until the next ":syntax case" command are affected.


DEFINING KEYWORDS					*:syn-keyword*

:sy[ntax] keyword {group-name} [{options}] {keyword} .. [{options}]

	This defines a number of keywords.

	{group-name}	Is a syntax group name such as "Comment".
	[{options}]	See |:syn-arguments| below.
	{keyword} ..	Is a list of keywords which are part of this group.

	Example:
>  :syntax keyword   Type   int long char

	The {options} can be given anywhere in the line.  They will apply to
	all keywords given, also for options that come after a keyword.
	These examples do exactly the same:
>  :syntax keyword   Type   contained int long char
>  :syntax keyword   Type   int long contained char
>  :syntax keyword   Type   int long char contained

	When you have a keyword with an optional tail, like Ex commands in
	Vim, you can put the optional characters inside [], to define all the
	variations at once:
>  :syntax keyword   VimCommand   ab[breviate] n[ext]

	Don't forget that a keyword can only be recognized if all the
	characters are included in the 'iskeyword' option.  If one character
	isn't, the keyword will never be recognized.

	A keyword always has higher priority than a match or region, the
	keyword is used if more than one item matches.  Keywords do not nest
	and a keyword can't contain anything else.

	Note that when you have a keyword that is the same as an option (even
	one that isn't allowed here), you can not use it.  Use a match
	instead.

	The maximum length of a keyword is 80 characters.

	The same keyword can be defined multiple times, when its containment
	differs.  For example, you can define the keyword once not contained
	and use one highlight group, and once contained, and use a different
	highlight group. Example:
>  :syn keyword vimCommand tag
>  :syn keyword vimSetting contained tag
	When finding "tag" outside of any syntax item, the "vimCommand"
	highlight group is used.  When finding "tag" in a syntax item that
	contains "vimSetting", the "vimSetting" group is used.


DEFINING MATCHES					*:syn-match*

:sy[ntax] match {group-name} [{options}] [excludenl] {pattern} [{options}]

	This defines one match.

	{group-name}		A syntax group name such as "Comment".
	[{options}]		See |:syn-arguments| below.
	[excludenl]		Don't make a pattern with the end-of-line "$"
				extend a containing match or region.  Must be
				given before the pattern. |:syn-excludenl|
	{pattern}		The search pattern that defines the match.
				See |:syn-pattern| below.

	Example (match a character constant):
>  :syntax match Character /'.'/s+1e-1


DEFINING REGIONS	*:syn-region* *:syn-start* *:syn-skip* *:syn-end*

:sy[ntax] region {group-name} [{options}]
		[matchgroup={group_name}]
		[keepend]
		[excludenl]
		start={start_pattern} ..
		[skip={skip_pattern}]
		end={end_pattern} ..
		[{options}]

	This defines one region.  It may span several lines.

	{group-name}		A syntax group name such as "Comment".
	[{options}]		See |:syn-arguments| below.
	[matchgroup={group-name}]  The syntax group to use for the following
				start or end pattern matches only.  Not used
				for the text in between the matched start and
				end patterns.  Use NONE to reset to not using
				a different group for the start or end match.
				See |:syn-matchgroup|.
	keepend			Don't allow contained matches to go past a
				match with the end pattern.  See
				|:syn-keepend|.
	excludenl		Don't make a pattern with the end-of-line "$"
				extend a containing match or item.  Only
				useful for end patterns.  Must be given before
				the patterns it applies to. |:syn-excludenl|
	start={start_pattern}	The search pattern that defines the start of
				the region.  See |:syn-pattern| below.
	skip={skip_pattern}	The search pattern that defines text inside
				the region where not to look for the end
				pattern.  See |:syn-pattern| below.
	end={end_pattern}	The search pattern that defines the end of
				the region.  See |:syn-pattern| below.

	Example:
>  :syntax region String   start=+"+  skip=+\\"+  end=+"+

	The start/skip/end patterns and the options can be given in any order.
	There can be zero or one skip pattern.  There must be one or more
	start and end patterns.  This means that you can omit the skip
	pattern, but you must give at least one start and one end pattern.  It
	is allowed to have white space before and after the equal sign
	(although it mostly looks better without white space).

	When more than one start pattern is given, a match with one of these
	is sufficient.  This means there is an OR relation between the start
	patterns.  The last one that matches is used.  The same is true for
	the end patterns.

	The search for the end pattern starts right after the start pattern.
	Offsets are not used for this.  This implies that the match for the
	end pattern will never overlap with the start pattern.

	Note: The decision to start a region is only based on a matching start
	pattern.  There is no check for a matching end pattern.  This does NOT
	work:
		:syn region First  start="("  end="."
		:syn region Second start="("  end=";"
	The Second always matches before the First (last defined pattern has
	higher priority).  The Second region then continues until the next
	';', no matter if there is a '.' before it.

							*:syn-keepend*
	By default, a contained match can obscure a match for the end pattern.
	This is useful for nesting.  For example, a region that starts with
	"{" and ends with "}", can contain another region.  An encountered "}"
	will then end the contained region, but not the outer region:
	    {		starts outer "{}" region
		{	starts contained "{}" region
		}	ends contained "{}" region
	    }		ends outer "{} region
	If you don't want this, the "keepend" argument will make the matching
	of an end pattern of the outer region also end any contained item.
	This makes it impossible to nest the same region, but allows for
	contained items to highlight parts of the end pattern, without causing
	that to skip the match with the end pattern.  Example:
>  :syn match  VimComment +"[^"]\+$+
>  :syn region VimCommand start="set" end="$" contains=VimComment keepend
	The "keepend" makes the VimCommand always end at the end of the line,
	even though the contained VimComment includes a match with the <EOL>.

	When "keepend" is not used, a match with an end pattern is retried
	after each contained match.  When "keepend" is included, the first
	encountered match with an end pattern is used, truncating any
	contained matches.

							*:syn-excludenl*
	When a pattern for a match or end pattern of a region includes a '$'
	to match the end-of-line, it will make an item that it is contained in
	continue on the next line.  For example, a match with "\\$" (backslash
	at the end of the line) can make a match continue that would normally
	stop at the end of the line.  This is the default behaviour.  If this
	is not wanted, there are two ways to avoid it:
	1. Use "keepend" for the the containing item.  This will keep all
	   contained matches from extending the match or region.  It can be
	   used when all contained items must not extend the containing item.
	2. Use "excludenl" in the contained item.  This will keep that match
	   from extending the containing match or region.  It can be used if
	   only some contained items must not extend the containing item.
	   "excludenl" must be given before the pattern it applies to.

							*:syn-matchgroup*
	"matchgroup" can be used to highlight the start and/or end pattern
	differently than the body of the region.  Example:
>  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+  end=+"+
	This will highlight the quotes with the "Quote" group, and the text in
	between with the "String" group.
	The "matchgroup" is used for all start and end patterns that follow,
	until the next "matchgroup".  Use "matchgroup=NONE" to go back to not
	using a matchgroup.

	In a start or end pattern that is highlighted with "matchgroup" the
	contained items of the region are not used.  This can be used to avoid
	that a contained item matches in the start or end pattern.  When using
	"transparent", it does not apply to a start or end pattern that is
	highlighted with "matchgroup".

	Here is an example, which highlights three levels of parentheses in
	different colors:
>  sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2
>  sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained
>  sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained
>  hi par1 ctermfg=red guifg=red
>  hi par2 ctermfg=blue guifg=blue
>  hi par3 ctermfg=darkgreen guifg=darkgreen

==============================================================================
6. :syntax arguments					*:syn-arguments*

The :syntax commands that define syntax items take a number of arguments.
The common ones are explained here.  The arguments may be given in any order
and may be mixed with patterns.

Not all commands accept all arguments.  This table shows which arguments
can be used for each command:

		 contained  nextgroup  skip*   transparent  contains  oneline ~
:syntax keyword	    yes	       yes	yes	   yes	       -	 -
:syntax match	    yes	       yes	yes	   yes	      yes	 -
:syntax region	    yes	       yes	yes	   yes	      yes	yes


contained						*:syn-contained*

When the "contained" argument is given, this item will not be recognized at
the top level, but only when it is mentioned in the "contains" field of
another match.  Example:
>   :syntax keyword Todo    TODO    contained
>   :syntax match   Comment "//.*"  contains=Todo


transparent						*:syn-transparent*

If the "transparent" argument is given, this item will not be highlighted
itself, but will take the highlighting of the item it is contained in.  This
is useful for syntax items that don't need any highlighting but are used
only to skip over a part of the text.

The "contains=" argument is also inherited from the item it is contained in,
unless a "contains" argument is given for the transparent item itself.  To
avoid that unwanted items are contained, use "contains=NONE".  Example, which
highlights words in strings, but makes an exception for "vim":
>	syn match myString /'[^']*'/ contains=myWord,myVim
>	syn match myWord   /\<[a-z]*\>/ contained
>	syn match myVim    /\<vim\>/ transparent contained contains=NONE
>	hi link myString String
>	hi link myWord   Comment
Since the "myVim" match comes after "myWord" it is the preferred match (last
match in the same position overrules an earlier one).  The "transparent"
argument makes the "myVim" match use the same highlighting as "myString".  But
it does not contain anything.  If the "contains=NONE" argument would be left
out, then "myVim" would use the contains argument from myString and allow
"myWord" to be contained, which will be highlighted as a Constant.  This
happens because a contained match doesn't match inside itself in the same
position, thus the "myVim" match doesn't overrule the "myWord" match here.

When you look at the colored text, it is like looking at layers of contained
items.  The contained item is on top of the item it is contained in, thus you
see the contained item.  When a contained item is transparent, you can look
through, thus you see the item it is contained in.  In a picture:

		look from here

	    |	|   |	|   |	|
	    V	V   V	V   V	V

	       xxxx	  yyy		more contained items
	    ....................	contained item (transparent)
	=============================	first item

The 'x', 'y' and '=' represent a highlighted syntax item.  The '.' represent a
transparent group.

What you see is:

	=======xxxx=======yyy========

Thus you look through the transparent "....".


oneline							*:syn-oneline*

The "oneline" argument indicates that the region does not cross a line
boundary.  It must match completely in the current line.  However, when the
region has a contained item that does cross a line boundary, it continues on
the next line anyway.  A contained item can be used to recognize a line
continuation pattern.


contains={groupname},..					*:syn-contains*

The "contains" argument is followed by a list of syntax group names.  These
groups will be allowed to begin inside the item (they may extend past the
containing group's end).  This allows for recursive nesting of matches and
regions.  If there is no "contains" argument, no groups will be contained in
this item.  The group names do not need to be defined before they can be used
here.

contains=ALL
		If the only item in the contains list is "ALL", then all
		groups will be accepted inside the item.

contains=ALLBUT,{group-name},..
		If the first item in the contains list is "ALLBUT", then all
		groups will be accepted inside the item, except the ones that
		are listed, and the "contained" items.  Example:
>  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function

The {group-name} in the "contains" list can be a pattern.  All group names
that match the pattern will be included (or excluded, if "ALLBUT" is used).
The pattern cannot contain white space or a ','.  Example:
>  ... contains=Comment.*,Keyw[0-3]
The matching will be done at moment the syntax command is executed.  Groups
that are defined later will not be matched.  Also, if the current syntax
command defines a new group, this is not matched.  Be careful: When putting
syntax commands in a file you can't rely on groups NOT being defined, because
the file may have been sourced before, and "syn clear" doesn't remove the
group names.

The contained groups will also match in the start and end patterns of a
region.  If this is not wanted, the "matchgroup" argument can be used
|:syn-matchgroup|.  The "ms=" and "me=" offsets can be used to change the
region where contained items do match.  Note that this may also limit the
area that is highlighted


nextgroup={groupname},..				*:syn-nextgroup*

The "nextgroup" argument is followed by a list of syntax group names,
separated by commas (just like with "contains", so you can also use patterns).

If the "nextgroup" argument is given, the mentioned syntax groups will be
tried for a match, after the match or region ends.  If none of the groups have
a match, highlighting continues normally.  If there is a match, this group
will used, even when it is not mentioned in the "contains" field of the
current group.  This is like giving the mentioned group priority over all
other groups.  Example:
>   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo
>   :syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller
>   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained

This will highlight "Foo" and "Bar" differently, and only when there is a
"Bar" after "Foo".  In the text line below, "f" shows where ccFoo is used for
highlighting, and "bbb" where ccBar is used.

>   Foo asdfasd Bar asdf Foo asdf Bar asdf
>   fff		bbb      fff      bbb

Note the use of ".\{-}" to skip as little as possible until the next Bar.
when ".*" would be used, the "asdf" in between "Bar" and "Foo" would be
highlighted according to the "ccFoobar" group, because the ccFooBar match
would include the first "Foo" and the last "Bar" in the line (see |pattern|).


skipwhite						*:syn-skipwhite*
skipnl							*:syn-skipnl*
skipempty						*:syn-skipempty*

These arguments are only used in combination with "nextgroup".  They can be
used to allow the next group to match after skipping some text:
	skipwhite	skip over space and Tab characters
	skipnl		skip over the end of a line
	skipempty	skip over empty lines (implies a "skipnl")

When "skipwhite" is present, the white space is only skipped if there is no
next group that matches the white space.

When "skipnl" is present, the match with nextgroup may be found in the next
line.  This only happens when the current item ends at the end of the current
line!  When "skipnl" is not present, the nextgroup will only be found after
the current item in the same line.

When skipping text while looking for a next group, the matches for other
groups are ignored.  Only when no next group matches, other items are tried
for a match again.  This means that matching a next group and skipping white
space and <EOL>s has a higher priority than other items.

Example:
>  syn match ifstart "if.*"     nextgroup=ifline skipwhite skipempty
>  syn match ifline  "endif"    contained
>  syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained
Note that the last match, which matches any non-white text, is put last,
otherwise the "endif" of the indent would never match, because the "[^ \t].*"
would match first.
Note that this example doesn't work for nested "if"s.  You need to add
"contains" arguments to make that work (omitted for simplicity of the
example).

==============================================================================
7. Syntax patterns					*:syn-pattern*

In the syntax commands, a pattern must be surrounded by two identical
characters.  This is like it works for the ":s" command.  The most common to
use is the double quote.  But if the pattern contains a double quote, you can
use another character that is not used in the pattern.  Examples:
>  :syntax region Comment  start="/\*"  end="\*/"
>  :syntax region String   start=+"+    end=+"+   skip=+\\"+

See |pattern| for the explanation of what a pattern is.  Syntax patterns are
always interpreted like the 'magic' options is set, no matter what the actual
value of 'magic' is.  And the patterns are interpreted like the 'l' flag is
not included in 'cpoptions'.  This was done to make syntax files portable and
independent of 'compatible' and 'magic' settings.

Try to avoid patterns that can match an empty string, such as "[a-z]*".
This slows down the highlighting a lot, because it matches everywhere.

The pattern can be followed by a character offset.  This can be used to
change the highlighted part, and to change the text area included in the
match or region (which only matters when trying to match other items).  Both
are relative to the matched pattern.  The character offset for a skip
pattern can be used to tell where to continue looking for an end pattern.

The offset takes the form of "{what}={offset}"
The {what} can be one of seven strings:

ms	Match Start	offset for the start of the matched text
me	Match End	offset for the end of the matched text
hs	Highlight Start	offset for where the highlighting starts
he	Highlight End	offset for where the highlighting ends
rs	Region Start	offset for where the body of a region starts
re	Region End	offset for where the body of a region ends
lc	Leading Context	offset past "leading context" of pattern

The {offset} can be:

s	start of the matched pattern
s+{nr}	start of the matched pattern plus {nr} chars to the right
s-{nr}	start of the matched pattern plus {nr} chars to the left
e	end of the matched pattern
e+{nr}	end of the matched pattern plus {nr} chars to the right
e-{nr}	end of the matched pattern plus {nr} chars to the left
{nr}	(for "lc" only): start matching {nr} chars to the left

Examples: "ms=s+1", "hs=e-2", "lc=3".

Although all offsets are accepted after any pattern, they are not always
meaningful.  This table shows which offsets are actually used:

		    ms   me   hs   he   rs   re	  lc ~
match item	    yes  yes  yes  yes  -    -    yes
region item start   yes  -    yes  -    yes  -    yes
region item skip    -    yes  -    -    -    -    -
region item end     -    yes  -    yes  -    yes  -

Offsets can be concatenated, with a ',' in between.  Example:
>  syn match String  /"[^"]*"/hs=s+1,he=e-1

    some "string" text
	  ^^^^^^		highlighted

Notes:
- There must be no white space between the pattern and the character
  offset(s).
- The highlighted area will never be outside of the matched text.
- A negative offset for an end pattern may not always work, because the end
  pattern may be detected when the highlighting should already have stopped.

Example (match a comment but don't highlight the /* and */):
>  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1

	/* this is a comment */
	  ^^^^^^^^^^^^^^^^^^^     highlighted

A more complicated Example:
>  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1

	 abcfoostringbarabc
	    mmmmmmmmmmm	    match
	      ssrrrreee	    highlight start/region/end ("Foo", "Exa" and "Bar")

Leading context			*:syn-lc* *:syn-leading* *:syn-context*

The "lc" offset specifies leading context -- a part of the pattern that must
be present, but is not considered part of the match.  An offset of "lc=n" will
cause Vim to step back n columns before attempting the pattern match, allowing
characters which have already been matched in previous patterns to also be
used as leading context for this match.  This can be used, for instance, to
specify that an "escaping" character must not precede the match:

>  :syn match ZNoBackslash "[^\\]z"ms=s+1
>  :syn match WNoBackslash "[^\\]w"lc=1
>  :syn match Underline "_\+"

	  ___zzzz ___wwww
	  ^^^     ^^^	  matches Underline
	      ^ ^	  matches ZNoBackslash
		     ^^^^ matches WNoBackslash

The "ms" offset is automatically set to the same value as the "lc" offset,
unless you set "ms" explicitly.

==============================================================================
8. Syntax clusters					*:syn-cluster*

:sy[ntax] cluster {cluster-name} [contains={group-name}..]
				 [add={group-name}..]
				 [remove={group-name}..]

This command allows you to cluster a list of syntax groups together under a
single name.

	contains={group-name}..
		The cluster is set to the specified list of groups.
	add={group-name}..
		The specified groups are added to the cluster.
	remove={group-name}..
		The specified groups are removed from the cluster.

A cluster so defined may be referred to in a contains=.., nextgroup=.., add=..
or remove=.. list with a "@" prefix.  You can also use this notation to
implicitly declare a cluster before specifying its contents.

Example:
>   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers
>   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2

As the previous example suggests, modifications to a cluster are effectively
retroactive; the membership of the cluster is checked at the last minute, so
to speak:
>   :syntax keyword A aaa
>   :syntax cluster AandB contains=A
>   :syntax match Stuff "( aaa bbb )" contains=@AandB
>   :syntax cluster AandB add=B    " now both keywords are matched in Stuff

This also has implications for nested clusters:
>   :syntax keyword A aaa
>   :syntax keyword B bbb
>   :syntax cluster SmallGroup contains=B
>   :syntax cluster BigGroup contains=A,@SmallGroup
>   :syntax match Stuff "( aaa bbb )" contains=@BigGroup
>   :syntax cluster BigGroup remove=B    " no effect, since B isn't in BigGroup
>   :syntax cluster SmallGroup remove=B  " now bbb isn't matched within Stuff

==============================================================================
9. Including syntax files				*:syn-include*

It is often useful for one language's syntax file to include a syntax file for
a related language.  Depending on the exact relationship, this can be done in
two different ways:

	- If top-level syntax items in the included syntax file are to be
	  allowed at the top level in the including syntax, you can simply use
	  the |:source| command:

>  " In cpp.vim:
>  :source <sfile>:p:h/c.vim

	- If top-level syntax items in the included syntax file are to be
	  contained within a region in the including syntax, you can use the
	  ":syntax include" command:

:sy[ntax] include [@{grouplist-name}] {file-name}

	  All syntax items declared in the included file will have the
	  "contained" flag added.  In addition, if a group list is specified,
	  all top-level syntax items in the included file will be added to
	  that list.

>   " In perl.vim:
>   :syntax include @Pod <sfile>:p:h/pod.vim
>   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod

==============================================================================
10. Synchronizing					*:syn-sync*

Vim wants to be able to start redrawing in any position in the document.  To
make this possible it needs to know the syntax item at the position where
redrawing starts.

:sy[ntax] sync [ccomment [group-name] | minlines={N} | ...]

There are three ways to synchronize:
1. Based on C-style comments.  Vim understands how C-comments work and can
   figure out if the current line starts inside or outside a comment.
   |:syn-sync-first|
2. Jumping back a certain number of lines and start parsing there.
   |:syn-sync-second|
3. Searching backwards in the text for a pattern to sync on.
   |:syn-sync-third|

				*:syn-sync-maxlines* *:syn-sync-minlines*
For all three methods, the line range where the parsing can start is limited
by "minlines" and "maxlines".

If the "minlines={N}" argument is given, the parsing always starts at least
that many lines backwards.  This can be used if the parsing may take a few
lines before it's correct, or when it's not possible to use syncing.

If the "maxlines={N}" argument is given, the number of lines that are searched
for a comment or syncing pattern is restricted to N lines backwards (after
adding "minlines".  This is useful if you have few things to sync on and a
slow machine.  Example:
>  :syntax sync ccomment maxlines=500


First syncing method:			*:syn-sync-first* *:syn-sync-ccomment*

For the first method, only the "ccomment" argument needs to be given.
Example:
>  :syntax sync ccomment

When Vim finds that the line where displaying starts is inside a C-style
comment, the last region syntax item with the group-name "Comment" will be
used.  This requires that there is a region with the group-name "Comment"!
An alternate group name can be specified, for example:
>  :syntax sync ccomment javaComment
This means that the last item specified with "syn region javaComment" will be
used for the detected C comment region.  This only works properly if that
region does have a start pattern "\/*" and an end pattern "*\/".

The "maxlines" argument can be used to restrict the search to a number of
lines.  The "minlines" argument can be used to at least start a number of
lines back (e.g., for when there is some construct that only takes a few
lines, but it hard to sync on).

Note: Syncing on a C comment doesn't work properly when strings are used
that cross a line and contain a "*/".  Since letting strings cross a line
is a bad programming habit (many compilers give a warning message), and the
chance of a "*/" appearing inside a comment is very small, this restriction
is hardly ever noticed.


Second syncing method:				*:syn-sync-second*

For the second method, only the "minlines={N}" argument needs to be given.
Vim will subtract {N} from the line number and start parsing there.  This
means {N} extra lines need to be parsed, which makes this method a bit slower.
Example:
>  :syntax sync minlines=50

"lines" is equivalent to "minlines" (used by older versions).


Third syncing method:				*:syn-sync-third*

The idea is to synchronize on the end of a few specific regions, called a
sync pattern.  Only regions can cross lines, so when we find the end of some
region, we might be able to know in which syntax item we are.  The search
starts in the line just above the one where redrawing starts.  From there
the search continues backwards in the file.

This works just like the non-syncing syntax items.  You can use contained
matches, nextgroup, etc.  But there are a few differences:
- Keywords cannot be used.
- The syntax items with the "sync" keyword form a completely separated group
  of syntax items.  You can't mix syncing groups and non-syncing groups.
- The matching works backwards in the buffer (line by line), instead of
  forwards.
- A line continuation pattern can be given.  It is used to decide which group
  of lines need to be searched like they were one line.  This means that the
  search for a match with the specified items starts in the first of the
  consecutive that contain the continuation pattern.
- When using "nextgroup" or "contains", this only works within one line (or
  group of continued lines).
- When a match with a sync pattern is found, the rest of the line (or group of
  continued lines) is searched for another match.  The last match is used.
  This is used when a line can contain both the start end the end of a region
  (e.g., in a C-comment like /* this */, the last "*/" is used).

There are two ways how a match with a sync pattern can be used:
1. Parsing for highlighting starts where redrawing starts (and where the
   search for the sync pattern started).  The syntax group that is expected
   to be valid there must be specified.  This works well when the regions
   that cross lines cannot contain other regions.
2. Parsing for highlighting continues just after the match.  The syntax group
   that is expected to be present just after the match must be specified.
   This can be used when the previous method doesn't work well.  It's much
   slower, because more text needs to be parsed.
Both types of sync patterns can be used at the same time.

Besides the sync patterns, other matches and regions can be specified, to
avoid finding unwanted matches.

[The reason that the sync patterns are given separately, is that mostly the
search for the sync point can be much simpler than figuring out the
highlighting.  The reduced number of patterns means it will go (much)
faster.]

						*syn-sync-grouphere*
    :syntax sync match {sync-group-name} grouphere {group-name} "pattern" ..

	Define a match that is used for syncing.  {group-name} is the
	name of a syntax group that follows just after the match.  Parsing
	of the text for highlighting starts just after the match.  A region
	must exist for this {group-name}.  The first one defined will be used.
	"NONE" can be used for when there is no syntax group after the match.

						*syn-sync-groupthere*
    :syntax sync match {sync-group-name} groupthere {group-name} "pattern" ..

	Like "grouphere", but {group-name} is the name of a syntax group that
	is to be used at the start of the line where searching for the sync
	point started.  The text between the match and the start of the sync
	pattern searching is assumed not to change the syntax highlighting.
	For example, in C you could search backwards for "/*" and "*/".  If
	"/*" is found first, you know that you are inside a comment, so the
	"groupthere" is "cComment".  If "*/" is found first, you know that you
	are not in a comment, so the "groupthere" is "NONE".  (in practice
	it's a bit more complicated, because the "/*" and "*/" could appear
	inside a string.  That's left as an exercise to the reader...).

    :syntax sync match ..
    :syntax sync region ..

	Without a "groupthere" argument.  Define a region or match that is
	skipped while searching for a sync point.

    :syntax sync linecont {pattern}

	When {pattern} matches in a line, it is considered to continue in
	the next line.  This means that the search for a sync point will
	consider the lines to be concatenated.

If the "maxlines={N}" argument is given too, the number of lines that are
searched for a match is restricted to N.  This is useful if you have very
few things to sync on and a slow machine.  Example:
>  :syntax sync maxlines=100

You can clear all sync settings with:
>  :syntax sync clear

You can clear specific sync patterns with:
>  :syntax sync clear {sync-group-name} ..

==============================================================================
11. Listing syntax items				*:syntax* *:sy* *:syn*

This commands lists all the syntax items:

    :sy[ntax] [list]

To show the syntax items for one syntax group:

    :sy[ntax] list {group-name}

To list the syntax groups in one group list:

    :sy[ntax] list @{grouplist-name}

See above for other arguments for the ":syntax" command.

Note that the ":syntax" command can be abbreviated to ":sy", although ":syn"
is mostly used, because it looks better.

==============================================================================
12. Highlight command					*:highlight* *:hi*

There are two types of highlight groups:
- The ones used for specific languages.  For these the name starts with the
  name of the language.  Many of these don't have any attributes, but are
  linked to a group of the second type.
- The ones used for all languages.  These are also used for the 'highlight'
  option.
							*hitest.vim*
You can see all the groups currently active with this command:
>   :so $VIMRUNTIME/syntax/hitest.vim
This will open a new window containing all highlight group names, displayed
in their own color.

:hi[ghlight]		List all the current highlight groups that have
			attributes set.

:hi[ghlight] {group-name}
			List one highlight group.

:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			Disable the highlighting for one highlight group.

:hi[ghlight] {group-name} {key}={arg} ..
			Add a highlight group, or change the highlighting for
			an existing group.  See below for the arguments
			|highlight-args|.

Normally a highlight group is added once, in the *.vim file.  This sets
the default values for the highlighting.  After that, you can use additional
highlight commands to change the arguments that you want to set to
non-default values.  The value "NONE" can be used to switch the value off or
go back to the default value.

Example.  The syntax.vim file contains this line:
>  hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff

You can change this by giving another ":highlight: command:
>  hi Comment	gui=bold

Note that all settings that are not included remain the same, only the
specified field is used, and settings are merged with previous ones.  So, the
result is like this single command has been used:
>  hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold

						*highlight-args*
There are three types of terminals for highlighting:
term	a normal terminal (vt100, xterm)
cterm	a color terminal (MS-DOS console, color-xterm, these have the "Co"
	termcap entry)
gui	the GUI

For each type the highlighting can be given.  This makes it possible to use
the same syntax file on all terminals, and use the optimal highlighting.

1. highlight arguments for normal terminals

term={attr-list}				*attr-list* *highlight-term*
	attr-list is a comma separated list (without spaces) of the
	following items (in any order):
		bold
		underline
		reverse
		inverse		same as reverse
		italic
		standout
		NONE		no attributes used (used to reset it)

	Note that "bold" can be used here and by using a bold font.  They
	have the same effect.

start={term-list}				*highlight-start*
stop={term-list}				*term-list* *highlight-stop*
	These lists of terminal codes can be used to get
	non-standard attributes on a terminal.

	The escape sequence specified with the "start" argument
	is written before the characters in the highlighted
	area.  It can be anything that you want to send to the
	terminal to highlight this area.  The escape sequence
	specified with the "stop" argument is written after the
	highlighted area.  This should undo the "start" argument.
	Otherwise the screen will look messed up.

	The {term-list} can have two forms:

	1. A string with escape sequences.
	   This is any string of characters, except that it can't start with
	   "t_" and blanks are not allowed.  The <> notation is recognized
	   here, so you can use things like "<Esc>" and "<Space>".  Example:
		start=<Esc>[27h;<Esc>[<Space>r;

	2. A list of terminal codes.
	   Each terminal code has the form "t_xx", where "xx" is the name of
	   the termcap entry.  The codes have to be separated with commas.
	   White space is not allowed.  Example:
		start=t_C1,t_BL
	   The terminal codes must exist for this to work.


2. highlight arguments for color terminals

cterm={attr-list}					*highlight-cterm*
	See above for the description of {attr-list} |attr-list|.
	The "cterm" argument is likely to be different from "term", when
	colors are used.  For example, in a normal terminal comments could
	be underlined, in a color terminal they can be made Blue.
	Note: Many terminals (e.g., DOS console) can't mix these attributes
	with coloring.  Use only one of "cterm=" OR "ctermfg=" OR "ctermbg=".

ctermfg={color-nr}					*highlight-ctermfg*
ctermbg={color-nr}					*highlight-ctermbg*
	The {color-nr} argument is a color number.  Its range is zero to
	(not including) the number given by the termcap entry "Co".
	The actual color with this number depends on the type of terminal
	and its settings.  Sometimes the color also depends on the settings of
	"cterm".  For example, on some systems "cterm=bold ctermfg=3" gives
	another color, on others you just get color 3.

	For an xterm this depends on your resources, and is a bit
	unpredictable.  See your xterm documentation for the defaults.  The
	colors for a color-xterm can be changed from the .Xdefaults file.
	Unfortunately this means that it's not possible to get the same colors
	for each user.  See |xterm-color| for info about color xterms.

	The MSDOS standard colors are fixed (in a console window), so these
	have been used for the names.  But the meaning of color names in X11
	are fixed, so these color settings have been used, to make the
	highlighting settings portable (complicated, isn't it?).  The
	following names are recognized, with the color number used:

	    NR-16   NR-8    COLOR NAME ~
							*cterm-colors*
	    0	    0	    Black
	    1	    4	    DarkBlue
	    2       2	    DarkGreen
	    3       6	    DarkCyan
	    4       1	    DarkRed
	    5       5	    DarkMagenta
	    6       3	    Brown
	    7       7	    LightGray, LightGrey, Gray, Grey
	    8	    0*	    DarkGray, DarkGrey
	    9	    4*	    Blue, LightBlue
	    10	    2*	    Green, LightGreen
	    11	    6*	    Cyan, LightCyan
	    12	    1*	    Red, LightRed
	    13	    5*	    Magenta, LightMagenta
	    14	    3*	    Yellow
	    15	    7*	    White

	The number under "NR-16" is used for 16-color terminals ('t_Co'
	greater than or equal to 16).  The number under "NR-8" is used for
	8-color terminals ('t_Co' less than 16).  The '*' indicates that the
	bold attribute is set for ctermfg.  In many 8-color terminals (e.g.,
	"linux"), this causes the bright colors to appear.  This doesn't work
	for background colors!  Without the '*' the bold attribute is removed.
	If you want to set the bold attribute in a different way, put a
	"cterm=" argument AFTER the "ctermfg=" or "ctermbg=" argument.  Or use
	a number instead of a color name.

	The case of the color names is ignored.
	Note that for 16 color ansi style terminals (including xterms), the
        numbers in the NR-8 column is used. Here '*' means 'add 8' so that Blue
        is 12, DarkGray is 8 etc.

	Note that for some color terminals these names may result in the wrong
	colors!

	When setting the "ctermfg" or "ctermbg" colors for the Normal group,
	these will become the colors used for the non-highlighted text.
	When setting the "ctermbg" color for the Normal group, the
	'background' option will be adjusted automatically.  This causes the
	highlight groups that depend on 'background' to change!  This means
	you should set the colors for Normal first, before setting other
	colors.

	When you have set "ctermfg" or "ctermbg" for the Normal group, Vim
	needs to reset the color when exiting.  This is done with the "op"
	termcap entry |t_op|.  If this doesn't work correctly, try setting the
	't_op' option in your .vimrc.

	When Vim knows the normal foreground and background colors, "fg" and
	"bg" can be used as color names.  This only works after setting the
	colors for the Normal group and for the MS-DOS console.  Example, for
	reverse video:
>	    :highlight Visual ctermfg=bg ctermbg=fg
	Note that the colors are used that are valid at the moment this
	command are given.  If the Normal group colors are changed later, the
	"fg" and "bg" colors will not be adjusted.


3. highlight arguments for the GUI

gui={attr-list}						*highlight-gui*
	These give the attributes to use in the GUI mode.
	See |attr-list| for a description.
	Note that "bold" can be used here and by using a bold font.  They
	have the same effect.
	Note that the attributes are ignored for the "Normal" group.

font={font-name}					*highlight-font*
	font-name is the name of a font, as it is used on the system Vim
	runs on.  For X11 this is a complicated name, for example:
>  font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1

	The font-name "NONE" can be used to revert to the default font.
	When setting the font for the "Normal" group, this becomes the default
	font (until the 'guifont' option is changed; the last one set is
	used).  All fonts used should be of the same character size as the
	default font!  Otherwise redrawing problems will occur.
	Setting the font does not work for the "Menu" group.

guifg={color-name}					*highlight-guifg*
guibg={color-name}					*highlight-guibg*
	These give the foreground (guifg) and background (guibg) color to
	use in the GUI.  There are a few special names:
		NONE		no color (transparent)
		bg		use normal background color
		background	use normal background color
		fg		use normal foreground color
		foreground	use normal foreground color
	To use a color name with an embedded space or other special character,
	put it in single quotes.  The single quote cannot be used then.
	Example:
>	    :hi comment guifg='salmon pink'

							*gui-colors*
	Suggested color names (these are available on most systems):
	    Red		LightRed	DarkRed
	    Green	LightGreen	DarkGreen	SeaGreen
	    Blue	LightBlue	DarkBlue	SlateBlue
	    Cyan	LightCyan	DarkCyan
	    Magenta	LightMagenta	DarkMagenta
	    Yellow	LightYellow	Brown
	    Gray	LightGray	DarkGray
	    Black	White
	    Orange	Purple		Violet

	In the Win32 GUI version, additional system colors are available.  See
	|win32-colors|.

	You can also specify a color by its Red, Green and Blue values.
	The format is "#rrggbb", where
		"rr"	is the Red value
		"bb"	is the Blue value
		"gg"	is the Green value
	All values are hexadecimal, range from "00" to "ff".  Examples:
>  :highlight Comment guifg=#11f0c3 guibg=#ff00ff

					*highlight-groups* *highlight-default*
These are the default highlighting groups.  These groups are used by the
'highlight' option default.  Note that the highlighting depends on the value
of 'background'.  You can see the current settings with the ":highlight"
command.
							*hl-Cursor*
Cursor		the character under the cursor
							*hl-Directory*
Directory	directory names (and other special names in listings)
							*hl-ErrorMsg*
ErrorMsg	error messages on the command line.
							*hl-IncSearch*
IncSearch	'incsearch' highlighting
							*hl-ModeMsg*
ModeMsg		'showmode' message (e.g., "-- INSERT --")
							*hl-MoreMsg*
MoreMsg		|more-prompt|
							*hl-NonText*
NonText		'~' and '@' at the end of the window and characters from
		'showbreak'
							*hl-Question*
Question	|hit-return| prompt and yes/no questions
							*hl-SpecialKey*
SpecialKey	Meta and special keys listed with ":map"
							*hl-StatusLine*
StatusLine	status line of current window
							*hl-StatusLineNC*
StatusLineNC	status lines of not-current windows
							*hl-Title*
Title		titles for output from ":set all", ":autocmd" etc.
							*hl-Visual*
Visual		Visual mode selection
							*hl-VisualNOS*
VisualNOS	Visual mode selection when vim is "Not Owning the Selection".
	        Only X11 Gui's |gui-x11| and |xterm-clipboard| supports this.
							*hl-WarningMsg*
WarningMsg	warning messages
							*hl-WildMenu*
WildMenu	current match in 'wildmenu' completion
							*hl-LineNr*
LineNr		line number for ":number" and ":#" commands, and when 'number'
		option is set.
							*hl-Normal*
Normal		normal text
							*hl-Search*
Search		last search pattern highlighting (see 'hlsearch')

							*hl-User1..9*
The 'statusline' syntax allows the use of 9 different highlights in the
statusline and ruler (via 'rulerformat'). The names are User1 to User9.

For the GUI you can use these groups to set the colors for the menu and
scrollbars.  They don't have defaults.  This doesn't work for the Win32 GUI.
    Menu						    *hl-Menu*
    Scrollbar						    *hl-Scrollbar*

==============================================================================
13. Linking groups					*:highlight-link*

When you want to use the same highlighting for several syntax groups, you
can do this more easily by linking the groups into one common highlight
group, and give the color attributes only for that group.

    :hi[ghlight][!] link {from-group} {to-group}

Notes:
- If the {from-group} and/or {to-group} doesn't exist, it is created.  You
  don't get an error message for a non-existing group.
- If the {to-group} is "NONE", the link is removed from the {from-group}.
- As soon as you use a ":highlight" command for a linked group, the link is
  removed.
- If there are already highlight settings for the {from-group}, the link is
  not made, unless the '!' is given.  For a ":highlight link" command in a
  sourced file, you don't get an error message.  This can be used to skip
  links for groups that already have settings.

==============================================================================
14. Cleaning up						*:syn-clear*

If you want to clear the syntax stuff for the current buffer, you can use this
command:
>  :syntax clear

This command should be used when you want to switch off syntax highlighting,
or when you want to switch to using another syntax.  It's a good idea to
include this command at the beginning of a syntax file.

If you want to disable syntax highlighting for all buffers, you need to remove
the autocommands that load the syntax files:
>  :syntax off

What this command actually does, is executing the command
>  source $VIMRUNTIME/syntax/nosyntax.vim
See the "nosyntax.vim" file for details.  Note that for this to work
$VIMRUNTIME must be valid.  See |$VIMRUNTIME|.

To clean up specific syntax groups for the current buffer:
>  :syntax clear {group-name} ..
This removes all patterns and keywords for {group-name}.

To clean up specific syntax group lists for the current buffer:
>  :syntax clear @{grouplist-name} ..
This sets {grouplist-name}'s contents to an empty list.

==============================================================================
15. Highlighting tags					*tag-highlight*

If you want to highlight all the tags in your file, you can use the following
mappings.

	<F11>	-- Generate tags.vim file, and highlight tags.
	<F12>	-- Just highlight tags based on existing tags.vim file.

>  map <F11>  :sp tags<CR>:%s/^\([^	:]*:\)\=\([^	]*\).*/syntax keyword Tag \2/<CR>:wq! tags.vim<CR>/^<CR><F12>
>  map <F12>  :so tags.vim<CR>

WARNING: The longer the tags file, the slower this will be, and the more
memory Vim will consume.

Only highlighting typedefs, unions and structs can be done too.  For this you
must use Exuberant ctags (included with Vim).

Put these lines in your Makefile:

# Make a highlight file for types.  Requires Exuberant ctags and awk
types: types.vim
types.vim: *.[ch]
	ctags -i=gstuS -o- *.[ch] |\
		awk 'BEGIN{printf("syntax keyword Type\t")}\
			{printf("%s ", $$1)}END{print ""}' > $@

And put these lines in your .vimrc:

>  " load the types.vim highlighting file, if it exists
>  autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'
>  autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)
>  autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname
>  autocmd BufRead,BufNewFile *.[ch] endif

==============================================================================
16. Color xterms				*xterm-color* *color-xterm*

Most color xterms have only eight colors.  They should work with these
lines in your .vimrc:
>  :if has("terminfo")
>  :  set t_Co=8
>  :  set t_Sf=<Esc>[3%p1%dm
>  :  set t_Sb=<Esc>[4%p1%dm
>  :else
>  :  set t_Co=8
>  :  set t_Sf=<Esc>[3%dm
>  :  set t_Sb=<Esc>[4%dm
>  :endif
	[<Esc> is a real escape, type CTRL-V <Esc>]

You might want to put these lines in an ":if" that checks the name of your
terminal, for example:
>  :if &term =~ "xterm"
   put above lines here
>  :endif

Note: Do these settings BEFORE doing ":syntax on".  Otherwise the colors may
be wrong.
							*xiterm* *rxvt*
The above settings have been mentioned to work for xiterm and rxvt too.

							*colortest.vim*
To test your color setup, a file has been included in the Vim distribution.
To use it, execute these commands:
>  :e $VIMRUNTIME/syntax/colortest.vim
>  :so %

Some versions of xterm (and other terminals, like the linux console) can
output lighter foreground colors, even though the number of colors is defined
at 8.  Therefore Vim sets the "cterm=bold" attribute for light foreground
colors, when 't_Co' is 8.

To get 16 colors, get the newest xterm version (which should be included with
Xfree86 3.3).  You can also find the latest version at:
	http://www.clark.net/pub/dickey/xterm
You probably have to enable 16 colors when running configure:
	./configure --disable-bold-color
If you only get 8 colors, check the xterm compilation settings.
(Also see |UTF8-xterm| for using this xterm with UTF-8 character encoding).

This xterm should work with these lines in your .vimrc:
>  :if has("terminfo")
>  :  set t_Co=16
>  :  set t_AB=<Esc>[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm
>  :  set t_AF=<Esc>[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm
>  :else
>  :  set t_Co=16
>  :  set t_Sf=<Esc>[3%dm
>  :  set t_Sb=<Esc>[4%dm
>  :endif
	[<Esc> is a real escape, type CTRL-V <Esc>]

Without |+terminfo|, Vim will recognize these settings, and automatically
translate cterm colors of 8 and above to "<Esc>[9%dm" and "<Esc>[10%dm".

Or just set the TERM environment variable to "xterm-16color" and try if that
works.

You probably want to use these X resources (in your ~/.Xdefaults file):
	XTerm*color0:			#000000
	XTerm*color1:			#c00000
	XTerm*color2:			#008000
	XTerm*color3:			#808000
	XTerm*color4:			#0000c0
	XTerm*color5:			#c000c0
	XTerm*color6:			#008080
	XTerm*color7:			#c0c0c0
	XTerm*color8:			#808080
	XTerm*color9:			#ff6060
	XTerm*color10:			#00ff00
	XTerm*color11:			#ffff00
	XTerm*color12:			#8080ff
	XTerm*color13:			#ff40ff
	XTerm*color14:			#00ffff
	XTerm*color15:			#ffffff
	Xterm*cursorColor:		Black

[Note: The cursorColor is required to work around a bug, which changes the
cursor color to the color of the last drawn text.  This has been fixed by a
newer version of xterm, but not everybody is it using yet.]

To get these right away, reload the .Xdefaults file to the X Option database
Manager (you only need to do this when you just changed the .Xdefaults file):
>  xrdb -merge ~/.Xdefaults

							*xterm-blink*
To make the cursor blink in an xterm, see tools/blink.c.  Or use Thomas
Dickey's xterm above patchlevel 107 (see above for where to get it), with
these resources:
	XTerm*cursorBlink:	on
	XTerm*cursorOnTime:	400
	XTerm*cursorOffTime:	250
	XTerm*cursorColor:	White

							*hpterm-color*
These settings work (more or less) for a hpterm, which only supports 8
foreground colors:
>  :if has("terminfo")
>  :  set t_Co=8
>  :  set t_Sf=<Esc>[&v%p1%dS
>  :  set t_Sb=<Esc>[&v7S
>  :else
>  :  set t_Co=8
>  :  set t_Sf=<Esc>[&v%dS
>  :  set t_Sb=<Esc>[&v7S
>  :endif
	[<Esc> is a real escape, type CTRL-V <Esc>]

						*Eterm* *enlightened-terminal*
These settings have been reported to work for the Enlightened terminal
emulator, or Eterm.  They might work for all xterm-like terminals that use the
bold attribute to get bright colors.  Add an ":if" like above when needed.
>      set t_Co=16
>      set t_AF=^[[%?%p1%{8}%<%t3%p1%d%e%p1%{22}%+%d;1%;m
>      set t_AB=^[[%?%p1%{8}%<%t4%p1%d%e%p1%{32}%+%d;1%;m

 vim:tw=78:ts=8:sw=4
